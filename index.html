<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Card Game Prototype — v28 (Targeting UI)</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(255,255,255,.06);
    --line:rgba(255,255,255,.12);
    --text:rgba(255,255,255,.92);
    --muted:rgba(255,255,255,.70);
    --good:#14532d;
    --warn:#7c2d12;
    --bad:#7f1d1d;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px;
    --hi:rgba(120,200,255,.70);
    --hi2:rgba(250,204,21,.70);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 40% -10%, rgba(125,211,252,.16), transparent),
      radial-gradient(900px 600px at 90% 10%, rgba(250,204,21,.10), transparent),
      var(--bg);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
  }
  header{
    position:sticky; top:0; z-index:60;
    backdrop-filter: blur(10px);
    background:linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.68));
    border-bottom:1px solid var(--line);
  }
  #jsStatus{
    background:var(--bad); color:#fff;
    padding:10px 12px; font-weight:900; font-size:13px;
    border-bottom:1px solid rgba(255,255,255,.12);
  }
  .bar{display:flex;gap:10px;align-items:center;justify-content:space-between; padding:10px 12px; flex-wrap:wrap}
  .title{font-weight:900}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{
    appearance:none;border:1px solid var(--line);background:var(--panel);color:var(--text);
    padding:9px 12px;border-radius:12px;font-weight:800;cursor:pointer
  }
  button:disabled{opacity:.45;cursor:not-allowed}
  button.primary{border-color:rgba(125,211,252,.35); box-shadow:0 0 0 1px rgba(125,211,252,.06) inset}
  button.warn{border-color:rgba(250,204,21,.45); background:rgba(250,204,21,.12)}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:5px 10px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid var(--line);font-size:12px}
  .wrap{display:grid;grid-template-columns: 1.55fr .45fr; gap:12px; padding:12px; max-width:1200px; margin:0 auto}
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  .panel{background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow: var(--shadow);}
  .panel h2{margin:0;padding:12px 12px 0 12px;font-size:14px;opacity:.95}
  .panel .inner{padding:12px}

  .zoneTitle{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .small{font-size:12px;color:var(--muted)}

  .slotRow{display:flex;gap:10px;flex-wrap:wrap}
  .slotRow.nowrap{flex-wrap:nowrap;overflow-x:auto;padding-bottom:6px}
  .slotRow.nowrap::-webkit-scrollbar{height:8px}
  .slotRow.nowrap::-webkit-scrollbar-thumb{background:rgba(255,255,255,.18);border-radius:999px}
  .slotRow.nowrap::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px}

  .slot{
    width:170px; min-width:170px;
    height:92px; border-radius:14px;
    border:1px dashed rgba(255,255,255,.18);
    display:flex;align-items:center;justify-content:center;
    color:rgba(255,255,255,.55);
    background:rgba(255,255,255,.03)
  }
  .card{
    width:170px; min-width:170px;
    background:linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,.04));
    border:1px solid var(--line);
    border-radius:14px;
    padding:10px;
    cursor:pointer;
    position:relative;
    user-select:none;
  }
  .card .name{font-weight:900;font-size:13px;line-height:1.2}
  .meta{margin-top:6px;font-size:12px;color:var(--muted);line-height:1.3}
  .badges{position:absolute;top:8px;right:8px;display:flex;gap:6px;flex-wrap:wrap;justify-content:flex-end}
  .badge{font-size:11px;padding:3px 8px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid var(--line)}
  .badge.info{background:rgba(29,78,216,.20);border-color:rgba(29,78,216,.45)}
  .badge.warn{background:rgba(124,45,18,.35);border-color:rgba(124,45,18,.6)}
  .badge.bad{background:rgba(127,29,29,.35);border-color:rgba(127,29,29,.65)}
  .badge.ok{background:rgba(20,83,45,.35);border-color:rgba(20,83,45,.60)}

  .cardActions{margin-top:8px;display:flex;gap:6px;flex-wrap:wrap}
  .miniBtn{padding:6px 8px;border-radius:10px;font-size:12px;font-weight:900}
  .miniBtn.swap{border-color:rgba(250,204,21,.55);background:rgba(250,204,21,.12)}

  .selectable{outline:2px solid var(--hi); box-shadow:0 0 0 4px rgba(60,120,200,.18) inset;}
  .swapSource{outline:2px solid var(--hi2); box-shadow:0 0 0 4px rgba(250,204,21,.14) inset;}
  .dim{opacity:.55}

  .heroGrid{display:grid;grid-template-columns: 1fr;gap:10px;}
  .heroRow{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-start;}
  .heroRowLabel{
    width:100%;
    font-weight:900;
    font-size:12px;
    color:rgba(255,255,255,.85);
    display:flex;
    align-items:center;
    justify-content:space-between;
  }

  /* target bar */
  #targetBar{
    display:none;
    position:sticky;
    top:0;
    z-index:55;
    margin:8px 12px 0;
    padding:10px 12px;
    border-radius:14px;
    background:rgba(20,40,70,.92);
    border:1px solid rgba(255,255,255,.14);
    gap:10px;
    align-items:center;
    justify-content:space-between;
  }
  #targetBar .msg{font-weight:900}
  #targetBar .sub{opacity:.85;font-size:12px}

  /* modal */
  #modalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:100}
  #modal{width:min(860px, 94vw); max-height: 90vh; overflow:auto; background:rgba(12,18,36,.92); border:1px solid var(--line);
          border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.6)}
  .modalHead{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px;border-bottom:1px solid var(--line)}
  .modalHead .h{font-weight:900}
  .modalBody{padding:12px}
  .hr{height:1px;background:var(--line);margin:10px 0}

  textarea#log{
    width:100%; min-height:240px;
    background:rgba(0,0,0,.22);
    color:#fff;
    border:1px solid rgba(255,255,255,.15);
    border-radius:14px;
    padding:10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size:12px;
    resize:vertical;
  }

  @media (max-width: 520px){
    .bar{flex-direction:column;align-items:stretch}
    .bar .row{justify-content:flex-start}
    .bar button{flex:1}
    .slot,.card{width:160px; min-width:160px}
  }
</style>
</head>
<body>
<div id="jsStatus">JS未起動 (v28)</div>
<noscript><div style="background:#b45309;color:#fff;padding:10px 12px;font-weight:800">JavaScriptが無効です（noscript）</div></noscript>

<header>
  <div class="bar">
    <div class="row">
      <div class="title">Card Game Prototype</div>
      <span class="chip" id="phaseChip">PHASE: MAIN</span>
      <span class="chip" id="turnChip">TURN: 1 / Active: P1</span>
      <span class="chip" id="manaChip">P1 Mana: 0 (0 untapped)</span>
    </div>
    <div class="row">
      <button class="primary" id="btnSetup">デモセットアップ</button>
      <button id="btnReset">リセット</button>
      <button id="btnEndTurn">ターン終了</button>
    </div>
  </div>
</header>

<div id="targetBar">
  <div>
    <div class="msg" id="targetMsg">対象を選択してください</div>
    <div class="sub" id="targetSub">Escでキャンセル</div>
  </div>
  <div class="row">
    <button class="warn" id="btnCancelTarget">キャンセル</button>
  </div>
</div>

<div class="wrap">
  <div class="panel">
    <h2>フィールド</h2>
    <div class="inner">

      <div class="panel" style="margin-bottom:12px">
        <h2>相手フィールド（P2：ミラー）</h2>
        <div class="inner">
          <div class="zoneTitle"><div style="font-weight:900">サポート・魔法</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="supportP2"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">インスタンス</div><div class="small">最大5（伏せ）</div></div>
          <div class="slotRow nowrap" id="instanceP2"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">ヒーロー（前衛/後衛）</div><div class="small">前後衛は可変（最低各1）</div></div>
          <div class="heroGrid" id="heroP2"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">モンスター</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="monsterP2"></div>
        </div>
      </div>

      <div class="panel">
        <h2>自分フィールド（P1）</h2>
        <div class="inner">
          <div class="zoneTitle"><div style="font-weight:900">モンスター</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="monsterP1"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">ヒーロー（前衛/後衛）</div><div class="small">入れ替え：1ターン1回/1マナ（戦闘不能は対象外）</div></div>
          <div class="heroGrid" id="heroP1"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">インスタンス</div><div class="small">最大5（相手から非公開／発動時のみ公開）</div></div>
          <div class="slotRow nowrap" id="instanceP1"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">サポート・魔法</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="supportP1"></div>

          <div class="hr"></div>
          <div class="zoneTitle"><div style="font-weight:900">手札（P1）</div><div class="small">クリックで詳細／発動で対象選択</div></div>
          <div class="slotRow nowrap" id="handP1"></div>
        </div>
      </div>

    </div>
  </div>

  <div class="panel">
    <h2>ログ</h2>
    <div class="inner">
      <textarea id="log" readonly></textarea>
      <div class="hr"></div>
      <div class="small">
        v28: 「対象選択（ターゲット）」UIを追加。<br/>
        対応target: enemyMonsterOne / allyMonsterOne / enemyHeroFrontOne / allyHeroFrontOne<br/>
        対応action(暫定): damage / destroy（destroyはHP=0扱い）<br/>
        ※本格的な戦闘/永続/優先権は次段階。
      </div>
    </div>
  </div>
</div>

<div id="modalBackdrop">
  <div id="modal">
    <div class="modalHead">
      <div class="h" id="modalTitle">詳細</div>
      <button id="btnCloseModal">閉じる</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
  </div>
</div>

<script>
(() => {
  "use strict";
  const VERSION = "v28";
  const $ = (id) => document.getElementById(id);
  const esc = (s) => String(s ?? "").replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;", "\"":"&quot;","'":"&#39;" }[m]));
  const now = () => new Date().toLocaleTimeString();

  const dom = {
    jsStatus: $("jsStatus"),
    phaseChip: $("phaseChip"),
    turnChip: $("turnChip"),
    manaChip: $("manaChip"),
    btnSetup: $("btnSetup"),
    btnReset: $("btnReset"),
    btnEndTurn: $("btnEndTurn"),
    log: $("log"),

    monsterP1: $("monsterP1"),
    heroP1: $("heroP1"),
    instanceP1: $("instanceP1"),
    supportP1: $("supportP1"),
    handP1: $("handP1"),

    monsterP2: $("monsterP2"),
    heroP2: $("heroP2"),
    instanceP2: $("instanceP2"),
    supportP2: $("supportP2"),

    modalBackdrop: $("modalBackdrop"),
    modalTitle: $("modalTitle"),
    modalBody: $("modalBody"),
    btnCloseModal: $("btnCloseModal"),

    targetBar: $("targetBar"),
    targetMsg: $("targetMsg"),
    targetSub: $("targetSub"),
    btnCancelTarget: $("btnCancelTarget"),
  };

  function log(msg){
    dom.log.value += `[${now()}] ${msg}\n`;
    dom.log.scrollTop = dom.log.scrollHeight;
  }

  function normType(d){
    const t = String(d.cardType ?? d.type ?? "").toLowerCase();
    if(t === "magic" || t === "spell") return "SPELL";
    if(t === "support") return "SUPPORT";
    if(t === "monster") return "MONSTER";
    if(t === "hero") return "HERO";
    if(t === "instance") return "INSTANCE";
    const u = String(d.cardType ?? "").toUpperCase();
    if(["SPELL","SUPPORT","MONSTER","HERO","INSTANCE"].includes(u)) return u;
    return "UNKNOWN";
  }

  const Z = {
    MON: "monster",
    HERO_F: "heroFront",
    HERO_B: "heroBack",
    INST: "instance",
    SUP: "support",
    HAND: "hand",
    MANA: "mana",
    GRAVE: "grave",
    BANISH: "banish",
  };

  function makeEmptyPlayer(){
    return {
      monster: new Array(7).fill(null),
      support: new Array(7).fill(null),
      instance: new Array(5).fill(null),
      heroFront: [],
      heroBack: [],
      hand: [],
      mana: [],
      grave: [],
      banish: [],
    };
  }

  function makeCardInst(id, owner){
    return {
      uid: `${owner}_${id}_${Math.random().toString(36).slice(2,9)}`,
      id, owner,
      faceDown: false,
      tapped: false,
      summonSick: false,
      _lp: null,
      _hp: null,
    };
  }

  const state = {
    defsById: new Map(),
    defsLoaded: false,
    turn: 1,
    active: "P1",
    phase: "MAIN",
    perTurn: {
      P1: { heroSwapUsed:false },
      P2: { heroSwapUsed:false },
    },
    players: {
      P1: makeEmptyPlayer(),
      P2: makeEmptyPlayer(),
    },

    heroSwap: { active:false, owner:"P1", fromRow:null, fromIndex:null },

    targeting: {
      active:false,
      owner:"P1",
      sourceRef:null,
      effect:null,
      candidates: [],
      prompt:"",
    }
  };

  function defOf(inst){ return inst ? (state.defsById.get(inst.id) ?? null) : null; }

  function ensureStats(inst){
    const d = defOf(inst);
    if(!d) return;
    const type = normType(d);
    if(type==="HERO"){
      if(inst._lp == null) inst._lp = Number(d.lp ?? 5);
    }
    if(type==="MONSTER"){
      if(inst._hp == null) inst._hp = Number(d.hp ?? 0);
    }
  }

  function manaAvailable(owner){
    return state.players[owner].mana.reduce((acc,c)=>acc + (!c.tapped ? 1 : 0), 0);
  }
  function manaTotal(owner){ return state.players[owner].mana.length; }
  function tapOneMana(owner){
    const c = state.players[owner].mana.find(x=>x && !x.tapped);
    if(!c) return false;
    c.tapped = true;
    return true;
  }
  function untapAllMana(owner){
    for(const c of state.players[owner].mana){ if(c) c.tapped=false; }
  }

  function isHeroKO(heroInst){
    if(!heroInst) return false;
    ensureStats(heroInst);
    return Number(heroInst._lp ?? 0) <= 0;
  }
  function isMonsterDead(monInst){
    if(!monInst) return false;
    ensureStats(monInst);
    return Number(monInst._hp ?? 0) <= 0;
  }

  async function loadDefs(){
    try{
      const url = new URL("cards.json", location.href);
      url.searchParams.set("t", Date.now());
      const res = await fetch(url.toString(), { cache:"no-store" });
      if(!res.ok) throw new Error("cards.json fetch failed: " + res.status);

      const data = await res.json();
      const arr = Array.isArray(data) ? data : (Array.isArray(data.cards) ? data.cards : null);
      if(!arr) throw new Error("cards.json format invalid (expected array or {cards:[...]})");

      const map = new Map();
      for(const d of arr){ if(d && d.id) map.set(d.id, d); }
      state.defsById = map;
      state.defsLoaded = true;
      log(`cards.json loaded (${map.size} cards)`);
    }catch(err){
      log("cards.json 読み込み失敗: " + (err?.message ?? String(err)));
      const fallback = [
        {id:"H_001", name:"フォールバックヒーロー", type:"hero", lp:5},
        {id:"M_001", name:"フォールバック兵", type:"monster", cost:1, atk:100, hp:200, effect:{target:"enemyMonsterOne", action:"damage", value:50}},
        {id:"SP_103", name:"フォールバック魔法", type:"magic", cost:1, effect:{target:"enemyMonsterOne", action:"damage", value:100}},
        {id:"SU_201", name:"フォールバック支援", type:"support", cost:1, lp:1},
        {id:"IN_301", name:"フォールバック・インスタンス", type:"instance", effect:{target:"enemyMonsterOne", action:"destroy", value:999}},
      ];
      state.defsById = new Map(fallback.map(x=>[x.id,x]));
    }
  }

  function resetGame(){
    state.turn = 1;
    state.active = "P1";
    state.phase = "MAIN";
    state.perTurn.P1.heroSwapUsed = false;
    state.perTurn.P2.heroSwapUsed = false;
    state.players.P1 = makeEmptyPlayer();
    state.players.P2 = makeEmptyPlayer();
    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    cancelTargeting(false);
    dom.log.value = "";
    log("リセットしました。");
    render();
  }

  function pickMany(filterFn, n){
    const out=[];
    for(const d of state.defsById.values()){
      if(filterFn(d)) out.push(d.id);
      if(out.length>=n) break;
    }
    return out;
  }

  function setupDemo(){
    resetGame();
    const heroIds = pickMany(d => normType(d)==="HERO", 4);
    const instIds = pickMany(d => normType(d)==="INSTANCE", 5);
    const monIds = pickMany(d => normType(d)==="MONSTER", 7);
    const supSpellIds = pickMany(d => ["SUPPORT","SPELL"].includes(normType(d)), 10);

    const p1 = state.players.P1;
    for(let i=0;i<4;i++){
      const id = heroIds[i] ?? "H_001";
      const c = makeCardInst(id, "P1");
      ensureStats(c);
      if(i<2) p1.heroFront.push(c); else p1.heroBack.push(c);
    }

    const p2 = state.players.P2;
    for(let i=0;i<4;i++){
      const id = heroIds[(i+1)%Math.max(1,heroIds.length)] ?? "H_001";
      const c = makeCardInst(id, "P2");
      ensureStats(c);
      if(i<2) p2.heroFront.push(c); else p2.heroBack.push(c);
    }

    for(let i=0;i<5;i++){
      const c1 = makeCardInst(instIds[i] ?? "IN_301","P1"); c1.faceDown=true; p1.instance[i]=c1;
      const c2 = makeCardInst(instIds[(i+1)%Math.max(1,instIds.length)] ?? "IN_301","P2"); c2.faceDown=true; p2.instance[i]=c2;
    }

    const handPool = [...monIds, ...supSpellIds, ...instIds].filter(Boolean);
    while(handPool.length<7){
      for(const d of state.defsById.values()){ handPool.push(d.id); if(handPool.length>=7) break; }
    }
    p1.hand = handPool.slice(0,7).map(id=>makeCardInst(id,"P1"));

    for(let i=0;i<3;i++){
      const id = p1.hand[i]?.id ?? (monIds[0] ?? "M_001");
      const c = makeCardInst(id,"P1"); p1.mana.push(c);
    }
    for(let i=0;i<2;i++){
      const id = monIds[i] ?? "M_001";
      const c = makeCardInst(id,"P2"); c.faceDown=true; p2.mana.push(c);
    }

    const om = makeCardInst(monIds[0] ?? "M_001","P2"); ensureStats(om); p2.monster[0]=om;
    const om2 = makeCardInst(monIds[1] ?? monIds[0] ?? "M_001","P2"); ensureStats(om2); p2.monster[1]=om2;

    const pm = makeCardInst(monIds[0] ?? "M_001","P1"); ensureStats(pm); p1.monster[0]=pm;

    const os = makeCardInst(supSpellIds[0] ?? "SU_201","P2"); os.faceDown=true; p2.support[0]=os;

    log("デモセットアップ完了。");
    render();
  }

  function endTurn(){
    state.active = (state.active==="P1") ? "P2" : "P1";
    if(state.active==="P1") state.turn += 1;

    state.perTurn[state.active].heroSwapUsed = false;
    untapAllMana(state.active);

    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    cancelTargeting(false);
    log(`ターン終了 → Active=${state.active} / Turn=${state.turn}`);
    render();
  }

  // ---------- Hero swap ----------
  function beginHeroSwap(owner, fromRow, fromIndex){
    if(owner !== state.active){ log("自分の手番ではありません。"); return; }
    if(owner !== "P1"){ log("プロトタイプではP1操作のみ"); return; }
    if(state.perTurn[owner].heroSwapUsed){ log("このターンは既に入れ替え済みです。"); return; }
    if(manaAvailable(owner) < 1){ log("マナ不足（入れ替えは1マナ）。"); return; }

    const p = state.players[owner];
    const src = (fromRow==="front") ? p.heroFront[fromIndex] : p.heroBack[fromIndex];
    if(!src) return;
    if(isHeroKO(src)){ log("戦闘不能ヒーローは入れ替え不可。"); return; }

    state.heroSwap.active = true;
    state.heroSwap.owner = owner;
    state.heroSwap.fromRow = fromRow;
    state.heroSwap.fromIndex = fromIndex;
    log("入れ替え先（反対列）を選択してください。");
    render();
  }

  function completeHeroSwap(owner, toRow, toIndex){
    if(!state.heroSwap.active) return;
    if(owner !== state.heroSwap.owner) return;

    const fromRow = state.heroSwap.fromRow;
    const fromIndex = state.heroSwap.fromIndex;
    if(fromRow === toRow){ log("反対列のヒーローを選択してください。"); return; }

    const p = state.players[owner];
    const srcArr = (fromRow==="front") ? p.heroFront : p.heroBack;
    const dstArr = (toRow==="front") ? p.heroFront : p.heroBack;
    const a = srcArr[fromIndex];
    const b = dstArr[toIndex];
    if(!a || !b) return;
    if(isHeroKO(a) || isHeroKO(b)){ log("戦闘不能ヒーローとの入れ替えは不可。"); return; }

    if(manaAvailable(owner) < 1 || !tapOneMana(owner)){ log("マナ消費に失敗しました。"); return; }

    srcArr[fromIndex] = b;
    dstArr[toIndex] = a;
    state.perTurn[owner].heroSwapUsed = true;

    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    log("ヒーローを入れ替えました（1マナ消費）。");
    render();
  }

  function cancelHeroSwap(){
    if(!state.heroSwap.active) return;
    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    log("入れ替えをキャンセルしました。");
    render();
  }

  // ---------- Targeting ----------
  function setTargetBar(show, msg, sub){
    dom.targetBar.style.display = show ? "flex" : "none";
    if(show){
      dom.targetMsg.textContent = msg || "対象を選択してください";
      dom.targetSub.textContent = sub || "Escでキャンセル";
    }
  }

  function cancelTargeting(writeLog=true){
    if(!state.targeting.active) return;
    state.targeting.active = false;
    state.targeting.sourceRef = null;
    state.targeting.effect = null;
    state.targeting.candidates = [];
    state.targeting.prompt = "";
    setTargetBar(false);
    if(writeLog) log("対象選択をキャンセルしました。");
    render();
  }

  function computeCandidates(effect){
    const t = String(effect?.target ?? "").trim();
    const p1 = state.players.P1;
    const p2 = state.players.P2;

    const cand = [];
    const push = (owner, zone, index) => cand.push({owner, zone, index});

    if(t === "enemyMonsterOne"){
      // enemy relative to active player
      const enemy = (state.active==="P1") ? "P2" : "P1";
      const arr = state.players[enemy].monster;
      arr.forEach((x,i)=>{ if(x) push(enemy, Z.MON, i); });
    }else if(t === "allyMonsterOne"){
      const ally = state.active;
      const arr = state.players[ally].monster;
      arr.forEach((x,i)=>{ if(x) push(ally, Z.MON, i); });
    }else if(t === "enemyHeroFrontOne"){
      const enemy = (state.active==="P1") ? "P2" : "P1";
      const arr = state.players[enemy].heroFront;
      arr.forEach((x,i)=>{ if(x && !isHeroKO(x)) push(enemy, Z.HERO_F, i); });
    }else if(t === "allyHeroFrontOne"){
      const ally = state.active;
      const arr = state.players[ally].heroFront;
      arr.forEach((x,i)=>{ if(x && !isHeroKO(x)) push(ally, Z.HERO_F, i); });
    }
    return cand;
  }

  function beginTargeting(sourceRef, effect){
    const candidates = computeCandidates(effect);
    if(candidates.length === 0){
      log("対象候補がありません（target条件を満たすカードがない）。");
      return;
    }
    state.targeting.active = true;
    state.targeting.owner = state.active;
    state.targeting.sourceRef = sourceRef;
    state.targeting.effect = effect;
    state.targeting.candidates = candidates;

    const t = String(effect?.target ?? "");
    setTargetBar(true, `対象を選択: ${t}`, "候補がハイライトされます（Escでキャンセル）");
    render();
  }

  function isCandidate(ref){
    if(!state.targeting.active) return false;
    return state.targeting.candidates.some(c => c.owner===ref.owner && c.zone===ref.zone && c.index===ref.index);
  }

  function getInstByRef(ref){
    const p = state.players[ref.owner];
    if(ref.zone===Z.MON) return p.monster[ref.index] ?? null;
    if(ref.zone===Z.SUP) return p.support[ref.index] ?? null;
    if(ref.zone===Z.INST) return p.instance[ref.index] ?? null;
    if(ref.zone===Z.HAND) return p.hand[ref.index] ?? null;
    if(ref.zone===Z.HERO_F) return p.heroFront[ref.index] ?? null;
    if(ref.zone===Z.HERO_B) return p.heroBack[ref.index] ?? null;
    return null;
  }

  function removeFromZone(ref){
    const p = state.players[ref.owner];
    if(ref.zone===Z.MON){ p.monster[ref.index]=null; return; }
    if(ref.zone===Z.SUP){ p.support[ref.index]=null; return; }
    if(ref.zone===Z.INST){ p.instance[ref.index]=null; return; }
    if(ref.zone===Z.HAND){ p.hand.splice(ref.index,1); return; }
    // HERO not removed here
  }

  function moveToGrave(inst){
    const p = state.players[inst.owner];
    p.grave.push(inst);
  }
  function moveToBanish(inst){
    const p = state.players[inst.owner];
    p.banish.push(inst);
  }

  function applyEffectToTarget(effect, targetRef){
    const action = String(effect?.action ?? "").trim();
    let value = effect?.value;
    const amount = (typeof value==="number") ? value : (typeof value==="string" ? Number(value) : (typeof value==="object" ? Number(value.amount ?? 0) : 0));

    const tgt = getInstByRef(targetRef);
    if(!tgt){ log("対象が見つかりません。"); return; }
    ensureStats(tgt);

    if(action === "damage"){
      if(targetRef.zone===Z.MON){
        tgt._hp = Math.max(0, Number(tgt._hp ?? 0) - Number(amount ?? 0));
        const name = defOf(tgt)?.name ?? tgt.id;
        log(`→ ${name} に ${amount} ダメージ（残HP:${tgt._hp}）`);
        if(isMonsterDead(tgt)){
          log(`→ ${name} は破壊され墓地へ。`);
          removeFromZone(targetRef);
          moveToGrave(tgt);
        }
      }else if(targetRef.zone===Z.HERO_F){
        tgt._lp = Math.max(0, Number(tgt._lp ?? 0) - Number(amount ?? 0));
        const name = defOf(tgt)?.name ?? tgt.id;
        log(`→ ${name} に ${amount} ダメージ（残LP:${tgt._lp}）`);
        if(isHeroKO(tgt)){
          tgt.tapped = true;
          log(`→ ${name} は戦闘不能（盤面に残留）。`);
        }
      }else{
        log("この対象へのdamageは未対応です。");
      }
    }else if(action === "destroy"){
      // destroy: monster=HP0 -> grave, hero=LP0 -> KO
      const name = defOf(tgt)?.name ?? tgt.id;
      if(targetRef.zone===Z.MON){
        tgt._hp = 0;
        log(`→ ${name} を破壊（墓地へ）。`);
        removeFromZone(targetRef);
        moveToGrave(tgt);
      }else if(targetRef.zone===Z.HERO_F){
        tgt._lp = 0;
        tgt.tapped = true;
        log(`→ ${name} を戦闘不能にしました（盤面残留）。`);
      }else{
        log("この対象へのdestroyは未対応です。");
      }
    }else{
      log(`action未対応: ${action}`);
    }
  }

  function resolveTargeting(targetRef){
    if(!state.targeting.active) return;
    if(!isCandidate(targetRef)) return;

    const effect = state.targeting.effect;
    const srcRef = state.targeting.sourceRef;

    const srcInst = getInstByRef(srcRef);
    const srcDef = srcInst ? defOf(srcInst) : null;
    const srcName = srcDef?.name ?? srcInst?.id ?? "不明カード";

    log(`効果解決: ${srcName} -> ${String(effect?.target ?? "")}`);
    applyEffectToTarget(effect, targetRef);

    // consume source card depending on type/zone (暫定)
    if(srcInst){
      const type = srcDef ? normType(srcDef) : "UNKNOWN";
      if(type==="INSTANCE"){
        // 発動時公開→除外（デュエル中再使用不可）
        removeFromZone(srcRef);
        srcInst.faceDown = false;
        moveToBanish(srcInst);
        log(`インスタンスは除外されました: ${srcName}`);
      }else if(type==="SPELL"){
        // 魔法は墓地へ（暫定）
        removeFromZone(srcRef);
        moveToGrave(srcInst);
        log(`魔法は墓地へ: ${srcName}`);
      }else if(type==="SUPPORT"){
        // サポートは設置型（手札から発動→場に置く／場から発動→残留）
        if(srcRef.zone===Z.HAND){
          // find empty support slot
          const p = state.players[srcInst.owner];
          const slot = p.support.findIndex(x=>!x);
          if(slot>=0){
            removeFromZone(srcRef);
            srcInst.faceDown = false;
            p.support[slot]=srcInst;
            log(`サポート設置: ${srcName}（スロット${slot+1}）`);
          }else{
            log("サポート枠が満杯のため設置できません。");
          }
        }else{
          srcInst.faceDown = false;
          log(`サポート発動（残留）: ${srcName}`);
        }
      }else if(type==="MONSTER"){
        log("モンスター効果のコスト/回数制限は未実装（暫定）。");
      }
    }

    cancelTargeting(false);
    render();
  }

  // ---------- Playing cards (minimal) ----------
  function canPay(cost){ return manaAvailable(state.active) >= cost; }
  function pay(cost){
    for(let i=0;i<cost;i++){
      if(!tapOneMana(state.active)) return false;
    }
    return true;
  }

  // ---------- Rendering ----------
  function updateTop(){
    dom.phaseChip.textContent = `PHASE: ${state.phase}`;
    dom.turnChip.textContent = `TURN: ${state.turn} / Active: ${state.active}`;
    dom.manaChip.textContent = `P1 Mana: ${manaTotal("P1")} (${manaAvailable("P1")} untapped) / SwapUsed:${state.perTurn.P1.heroSwapUsed?"Y":"N"}`;
  }

  function cardLabel(inst, viewer){
    const d = defOf(inst);
    if(!d) return {name: inst.id, meta:"", badges:[]};
    const type = normType(d);
    const facedown = (viewer !== inst.owner) && inst.faceDown;

    ensureStats(inst);

    if(facedown){
      if(type==="INSTANCE") return {name:"インスタンス（伏せ）", meta:"", badges:[{t:"伏せ", cls:"info"}]};
      return {name:"（伏せ）", meta:"", badges:[{t:"伏せ", cls:"info"}]};
    }

    const badges=[];
    if(type==="HERO") badges.push({t:"HERO", cls:"info"});
    if(type==="MONSTER") badges.push({t:(d.subType??"").toString()||"MON", cls:"info"});
    if(type==="SUPPORT") badges.push({t:"SUP", cls:"info"});
    if(type==="SPELL") badges.push({t:"MAG", cls:"info"});
    if(type==="INSTANCE") badges.push({t:"INST", cls:"info"});
    if(type==="HERO" && isHeroKO(inst)) badges.push({t:"戦闘不能", cls:"bad"});

    let meta="";
    if(type==="HERO") meta = `LP:${inst._lp ?? (d.lp ?? "-")}`;
    else if(type==="MONSTER") meta = `Cost:${d.cost??0} / ATK:${d.atk??"-"} / HP:${inst._hp ?? (d.hp ?? "-")}`;
    else if(type==="SUPPORT") meta = `Cost:${d.cost??0} / LP:${d.lp??1}`;
    else if(type==="SPELL") meta = `Cost:${d.cost??0}`;
    else if(type==="INSTANCE") meta = "（デュエル中1回）";

    return {name:d.name ?? inst.id, meta, badges};
  }

  function renderSlotsRow(container, arr, viewer, zoneKey){
    container.innerHTML="";
    for(let i=0;i<arr.length;i++){
      const inst = arr[i];
      if(!inst){
        const ph=document.createElement("div"); ph.className="slot"; ph.textContent="—"; container.appendChild(ph); continue;
      }
      const lbl = cardLabel(inst, viewer);
      const el=document.createElement("div"); el.className="card";

      const ref = {owner:inst.owner, zone:zoneKey, index:i};

      // targeting visuals
      if(state.targeting.active){
        if(isCandidate(ref)) el.classList.add("selectable");
        else el.classList.add("dim");
      }

      el.addEventListener("click", (ev)=>{
        if(state.targeting.active){
          ev.stopPropagation();
          if(isCandidate(ref)) resolveTargeting(ref);
          return;
        }
        openCardDetails(ref);
      });

      const badges=document.createElement("div"); badges.className="badges";
      for(const b of lbl.badges){
        const be=document.createElement("span"); be.className="badge "+(b.cls||""); be.textContent=b.t; badges.appendChild(be);
      }
      el.appendChild(badges);

      const nm=document.createElement("div"); nm.className="name"; nm.textContent=lbl.name; el.appendChild(nm);
      const meta=document.createElement("div"); meta.className="meta"; meta.textContent=lbl.meta; el.appendChild(meta);
      container.appendChild(el);
    }
  }

  function renderHeroGrid(container, owner, viewer){
    const p = state.players[owner];
    container.innerHTML="";

    const frontLabel=document.createElement("div");
    frontLabel.className="heroRowLabel";
    frontLabel.innerHTML = `<span>前衛（${p.heroFront.length}）</span><span class="small">最低1</span>`;
    const frontRow=document.createElement("div"); frontRow.className="heroRow";

    const backLabel=document.createElement("div");
    backLabel.className="heroRowLabel";
    backLabel.innerHTML = `<span>後衛（${p.heroBack.length}）</span><span class="small">最低1</span>`;
    const backRow=document.createElement("div"); backRow.className="heroRow";

    container.appendChild(frontLabel); container.appendChild(frontRow);
    container.appendChild(backLabel); container.appendChild(backRow);

    function heroCard(inst, rowName, idx){
      ensureStats(inst);
      const lbl = cardLabel(inst, viewer);
      const el=document.createElement("div"); el.className="card";

      const ref = {owner:inst.owner, zone:(rowName==="front"?Z.HERO_F:Z.HERO_B), index:idx};

      // targeting visuals
      if(state.targeting.active){
        if(isCandidate(ref)) el.classList.add("selectable");
        else el.classList.add("dim");
      }

      // hero swap visuals
      const swapMode = state.heroSwap.active && owner===state.heroSwap.owner;
      if(swapMode){
        if(state.heroSwap.fromRow===rowName && state.heroSwap.fromIndex===idx){
          el.classList.add("swapSource");
        }else if(rowName !== state.heroSwap.fromRow && !isHeroKO(inst)){
          el.classList.add("selectable");
        }
      }

      el.addEventListener("click", (ev)=>{
        if(state.targeting.active){
          ev.stopPropagation();
          if(isCandidate(ref)) resolveTargeting(ref);
          return;
        }
        if(swapMode){
          ev.stopPropagation();
          if(rowName !== state.heroSwap.fromRow){
            completeHeroSwap(owner, rowName, idx);
          }else{
            openCardDetails(ref);
          }
          return;
        }
        openCardDetails(ref);
      });

      const badges=document.createElement("div"); badges.className="badges";
      for(const b of lbl.badges){
        const be=document.createElement("span"); be.className="badge "+(b.cls||""); be.textContent=b.t; badges.appendChild(be);
      }
      el.appendChild(badges);

      const nm=document.createElement("div"); nm.className="name"; nm.textContent=lbl.name; el.appendChild(nm);
      const meta=document.createElement("div"); meta.className="meta"; meta.textContent=lbl.meta; el.appendChild(meta);

      if(inst.owner==="P1"){
        const actions=document.createElement("div"); actions.className="cardActions";
        const swapBtn=document.createElement("button");
        swapBtn.className="miniBtn swap";
        swapBtn.textContent = state.heroSwap.active ? "キャンセル" : "入れ替え";
        swapBtn.disabled = (inst.owner!==state.active) || isHeroKO(inst) || state.perTurn.P1.heroSwapUsed || manaAvailable("P1")<1 || state.targeting.active;
        swapBtn.addEventListener("click", (ev)=>{
          ev.stopPropagation();
          if(state.heroSwap.active) cancelHeroSwap();
          else beginHeroSwap("P1", rowName, idx);
        });
        actions.appendChild(swapBtn);
        el.appendChild(actions);
      }
      return el;
    }

    if(p.heroFront.length===0){
      const ph=document.createElement("div"); ph.className="slot"; ph.textContent="（前衛なし）"; frontRow.appendChild(ph);
    }else{
      p.heroFront.forEach((inst,i)=>frontRow.appendChild(heroCard(inst,"front",i)));
    }

    if(p.heroBack.length===0){
      const ph=document.createElement("div"); ph.className="slot"; ph.textContent="（後衛なし）"; backRow.appendChild(ph);
    }else{
      p.heroBack.forEach((inst,i)=>backRow.appendChild(heroCard(inst,"back",i)));
    }
  }

  function renderHand(){
    dom.handP1.innerHTML="";
    const p1=state.players.P1;
    const max=Math.max(7,p1.hand.length);
    for(let i=0;i<max;i++){
      const inst=p1.hand[i];
      if(!inst){ const ph=document.createElement("div"); ph.className="slot"; ph.textContent="—"; dom.handP1.appendChild(ph); continue; }
      const lbl=cardLabel(inst,"P1");
      const el=document.createElement("div"); el.className="card";
      const ref={owner:"P1", zone:Z.HAND, index:i};

      if(state.targeting.active){
        el.classList.add("dim");
      }

      el.addEventListener("click", ()=>{ if(!state.targeting.active) openCardDetails(ref); });

      const badges=document.createElement("div"); badges.className="badges";
      for(const b of lbl.badges){
        const be=document.createElement("span"); be.className="badge "+(b.cls||""); be.textContent=b.t; badges.appendChild(be);
      }
      el.appendChild(badges);
      const nm=document.createElement("div"); nm.className="name"; nm.textContent=lbl.name; el.appendChild(nm);
      const meta=document.createElement("div"); meta.className="meta"; meta.textContent=lbl.meta; el.appendChild(meta);
      dom.handP1.appendChild(el);
    }
  }

  function render(){
    updateTop();
    renderSlotsRow(dom.supportP2, state.players.P2.support, "P1", Z.SUP);
    // opponent instance always facedown
    renderSlotsRow(dom.instanceP2, state.players.P2.instance.map(x=>x?({...x,faceDown:true}):null), "P1", Z.INST);
    renderHeroGrid(dom.heroP2, "P2", "P1");
    renderSlotsRow(dom.monsterP2, state.players.P2.monster, "P1", Z.MON);

    renderSlotsRow(dom.monsterP1, state.players.P1.monster, "P1", Z.MON);
    renderHeroGrid(dom.heroP1, "P1", "P1");
    // your instance shown facedown too (reveal only on activate)
    renderSlotsRow(dom.instanceP1, state.players.P1.instance.map(x=>x?({...x,faceDown:true}):null), "P1", Z.INST);
    renderSlotsRow(dom.supportP1, state.players.P1.support, "P1", Z.SUP);
    renderHand();
  }

  // ---------- Modal ----------
  function openModal(title, bodyHtml){
    dom.modalTitle.textContent=title;
    dom.modalBody.innerHTML=bodyHtml;
    dom.modalBackdrop.style.display="flex";
  }
  function closeModal(){
    dom.modalBackdrop.style.display="none";
    dom.modalBody.innerHTML="";
  }

  function openCardDetails(ref){
    const inst = getInstByRef(ref);
    if(!inst) return;
    const d = defOf(inst);
    const type = d ? normType(d) : "UNKNOWN";
    ensureStats(inst);

    const viewer = "P1";
    const facedown = (viewer !== inst.owner) && inst.faceDown;
    const header = facedown ? "（伏せカード）" : (d?.name ?? inst.id);
    const meta = facedown ? "" : `${type} / Cost:${d?.cost ?? 0}`;
    let stats="";
    if(!facedown){
      if(type==="MONSTER") stats=`ATK:${d?.atk ?? "-"} / HP:${inst._hp ?? (d?.hp ?? "-")}`;
      if(type==="HERO") stats=`LP:${inst._lp ?? (d?.lp ?? "-")}`;
      if(type==="SUPPORT") stats=`LP:${d?.lp ?? 1}`;
    }
    const text = facedown ? "" : (d?.text ?? "");

    // action buttons (minimal for targeting)
    const buttons = [];
    const effect = d?.effect ?? null;

    // we allow "activate" only if effect exists and has supported target
    const supportedTargets = new Set(["enemyMonsterOne","allyMonsterOne","enemyHeroFrontOne","allyHeroFrontOne"]);
    const hasTargetedEffect = effect && supportedTargets.has(String(effect.target ?? ""));
    const cost = Number(d?.cost ?? 0);

    if(inst.owner==="P1" && state.active==="P1" && !state.targeting.active){
      if(type==="SPELL" || type==="SUPPORT" || type==="INSTANCE" || type==="MONSTER"){
        if(hasTargetedEffect){
          buttons.push(`<button class="primary" data-act="activate">発動（対象選択）</button>`);
        }else if(effect){
          buttons.push(`<button class="primary" data-act="activateNoTarget">発動（対象なし/未対応）</button>`);
        }
      }
    }

    // hero controls (swap + test)
    let heroControls = "";
    if(type==="HERO" && inst.owner==="P1"){
      const rowName = (ref.zone===Z.HERO_F) ? "front" : "back";
      const swapDisabled = (inst.owner!==state.active) || isHeroKO(inst) || state.perTurn.P1.heroSwapUsed || manaAvailable("P1")<1 || state.targeting.active;
      heroControls = `
        <div class="hr"></div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="warn" ${swapDisabled?"disabled":""} data-act="beginSwap" data-row="${rowName}" data-idx="${ref.index}">入れ替え開始（1マナ）</button>
          <button ${state.heroSwap.active?"":"disabled"} data-act="cancelSwap">入れ替えキャンセル</button>
          <button data-act="testKO">（テスト）LP=0</button>
          <button data-act="testHeal">（テスト）LP+2</button>
        </div>
      `;
    }

    openModal(header, `
      <div class="small">${esc(meta)}</div>
      <div class="hr"></div>
      <div>${esc(stats)}</div>
      <div class="hr"></div>
      <div class="small">${esc(text)}</div>
      <div class="hr"></div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">${buttons.join("") || `<span class="small">（発動UIは、target付き効果のみ対象選択に入ります）</span>`}</div>
      ${heroControls}
      <div class="hr"></div>
      <div class="small">Owner:${esc(inst.owner)} / Zone:${esc(ref.zone)} / Index:${ref.index}</div>
    `);

    // bind modal actions
    dom.modalBody.querySelectorAll("[data-act]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const act=btn.getAttribute("data-act");
        if(act==="beginSwap"){
          const row=btn.getAttribute("data-row");
          const idx=Number(btn.getAttribute("data-idx"));
          closeModal();
          beginHeroSwap("P1", row, idx);
        }else if(act==="cancelSwap"){
          cancelHeroSwap();
          closeModal();
        }else if(act==="testKO"){
          inst._lp = 0;
          inst.tapped = true;
          log("（テスト）ヒーローを戦闘不能にしました。");
          render();
          closeModal();
        }else if(act==="testHeal"){
          inst._lp = Math.max(0, Number(inst._lp ?? 0) + 2);
          if(inst._lp > 0) inst.tapped = false;
          log("（テスト）ヒーローを回復しました。");
          render();
          closeModal();
        }else if(act==="activate"){
          closeModal();
          // cost pay (暫定)
          if(cost>0){
            if(!canPay(cost)){ log(`マナ不足（必要${cost} / 残${manaAvailable("P1")}）。`); return; }
            pay(cost);
            log(`コスト支払い: ${cost}（マナをタップ）`);
          }
          // reveal instance on activate
          if(type==="INSTANCE") inst.faceDown=false;
          beginTargeting(ref, effect);
        }else if(act==="activateNoTarget"){
          closeModal();
          log("この効果は target 形式が未対応です（v28では対象選択のみ実装）。");
        }
      });
    });
  }

  // ---------- Events ----------
  function bind(){
    dom.btnSetup.addEventListener("click", setupDemo);
    dom.btnReset.addEventListener("click", resetGame);
    dom.btnEndTurn.addEventListener("click", endTurn);

    dom.btnCloseModal.addEventListener("click", closeModal);
    dom.modalBackdrop.addEventListener("click", (e)=>{ if(e.target===dom.modalBackdrop) closeModal(); });

    dom.btnCancelTarget.addEventListener("click", ()=>cancelTargeting(true));

    window.addEventListener("keydown", (e)=>{
      if(e.key==="Escape"){
        if(state.targeting.active) cancelTargeting(true);
        if(state.heroSwap.active) cancelHeroSwap();
        closeModal();
      }
    });
  }

  async function init(){
    dom.jsStatus.style.background = "var(--good)";
    dom.jsStatus.textContent = `JS ready (${VERSION})`;
    bind();
    await loadDefs();
    render();
  }

  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", init, {once:true});
  }else{
    init();
  }
})();
</script>
</body>
</html>
