<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Card Game Prototype — v27 (Hero Front/Back Swap)</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(255,255,255,.06);
    --line:rgba(255,255,255,.12);
    --text:rgba(255,255,255,.92);
    --muted:rgba(255,255,255,.70);
    --good:#14532d;
    --warn:#7c2d12;
    --bad:#7f1d1d;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px;
    --hi:rgba(120,200,255,.65);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 40% -10%, rgba(125,211,252,.16), transparent),
      radial-gradient(900px 600px at 90% 10%, rgba(250,204,21,.10), transparent),
      var(--bg);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
  }
  header{
    position:sticky; top:0; z-index:50;
    backdrop-filter: blur(10px);
    background:linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.68));
    border-bottom:1px solid var(--line);
  }
  #jsStatus{
    background:var(--bad); color:#fff;
    padding:10px 12px; font-weight:900; font-size:13px;
    border-bottom:1px solid rgba(255,255,255,.12);
  }
  .bar{display:flex;gap:10px;align-items:center;justify-content:space-between; padding:10px 12px; flex-wrap:wrap}
  .title{font-weight:900}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{
    appearance:none;border:1px solid var(--line);background:var(--panel);color:var(--text);
    padding:9px 12px;border-radius:12px;font-weight:800;cursor:pointer
  }
  button:disabled{opacity:.45;cursor:not-allowed}
  button.primary{border-color:rgba(125,211,252,.35); box-shadow:0 0 0 1px rgba(125,211,252,.06) inset}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:5px 10px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid var(--line);font-size:12px}
  .wrap{display:grid;grid-template-columns: 1.55fr .45fr; gap:12px; padding:12px; max-width:1200px; margin:0 auto}
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  .panel{background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow: var(--shadow);}
  .panel h2{margin:0;padding:12px 12px 0 12px;font-size:14px;opacity:.95}
  .panel .inner{padding:12px}

  .zoneTitle{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .small{font-size:12px;color:var(--muted)}

  .slotRow{display:flex;gap:10px;flex-wrap:wrap}
  .slotRow.nowrap{flex-wrap:nowrap;overflow-x:auto;padding-bottom:6px}
  .slotRow.nowrap::-webkit-scrollbar{height:8px}
  .slotRow.nowrap::-webkit-scrollbar-thumb{background:rgba(255,255,255,.18);border-radius:999px}
  .slotRow.nowrap::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px}

  .slot{
    width:170px; min-width:170px;
    height:92px; border-radius:14px;
    border:1px dashed rgba(255,255,255,.18);
    display:flex;align-items:center;justify-content:center;
    color:rgba(255,255,255,.55);
    background:rgba(255,255,255,.03)
  }
  .slot.fill{border-style:solid;background:rgba(255,255,255,.05)}

  .card{
    width:170px; min-width:170px;
    background:linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,.04));
    border:1px solid var(--line);
    border-radius:14px;
    padding:10px;
    cursor:pointer;
    position:relative;
    user-select:none;
  }
  .card .name{font-weight:900;font-size:13px;line-height:1.2}
  .meta{margin-top:6px;font-size:12px;color:var(--muted);line-height:1.3}
  .badges{position:absolute;top:8px;right:8px;display:flex;gap:6px;flex-wrap:wrap;justify-content:flex-end}
  .badge{font-size:11px;padding:3px 8px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid var(--line)}
  .badge.warn{background:rgba(124,45,18,.35);border-color:rgba(124,45,18,.6)}
  .badge.info{background:rgba(29,78,216,.20);border-color:rgba(29,78,216,.45)}
  .badge.bad{background:rgba(127,29,29,.35);border-color:rgba(127,29,29,.65)}

  .card.selectable{outline:2px solid var(--hi); box-shadow:0 0 0 4px rgba(60,120,200,.18) inset;}
  .card.swapSource{outline:2px solid rgba(250,204,21,.65); box-shadow:0 0 0 4px rgba(250,204,21,.14) inset;}

  .cardActions{
    margin-top:8px;
    display:flex; gap:6px; flex-wrap:wrap;
  }
  .miniBtn{
    padding:6px 8px;
    border-radius:10px;
    font-size:12px;
    font-weight:900;
  }
  .miniBtn.swap{
    border-color:rgba(250,204,21,.55);
    background:rgba(250,204,21,.12);
  }

  .heroGrid{display:grid;grid-template-columns: 1fr;gap:10px;}
  .heroRow{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-start;}
  .heroRowLabel{
    width:100%;
    font-weight:900;
    font-size:12px;
    color:rgba(255,255,255,.85);
    display:flex;
    align-items:center;
    justify-content:space-between;
  }

  /* modal */
  #modalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:100}
  #modal{width:min(860px, 94vw); max-height: 90vh; overflow:auto; background:rgba(12,18,36,.92); border:1px solid var(--line);
          border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.6)}
  .modalHead{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px;border-bottom:1px solid var(--line)}
  .modalHead .h{font-weight:900}
  .modalBody{padding:12px}
  .hr{height:1px;background:var(--line);margin:10px 0}

  textarea#log{
    width:100%; min-height:240px;
    background:rgba(0,0,0,.22);
    color:#fff;
    border:1px solid rgba(255,255,255,.15);
    border-radius:14px;
    padding:10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size:12px;
    resize:vertical;
  }

  @media (max-width: 520px){
    .bar{flex-direction:column;align-items:stretch}
    .bar .row{justify-content:flex-start}
    .bar button{flex:1}
    .slot,.card{width:160px; min-width:160px}
  }
</style>
</head>
<body>
<div id="jsStatus">JS未起動 (v27)</div>
<noscript><div style="background:#b45309;color:#fff;padding:10px 12px;font-weight:800">JavaScriptが無効です（noscript）</div></noscript>

<header>
  <div class="bar">
    <div class="row">
      <div class="title">Card Game Prototype</div>
      <span class="chip" id="phaseChip">PHASE: MAIN</span>
      <span class="chip" id="turnChip">TURN: 1 / Active: P1</span>
      <span class="chip" id="manaChip">P1 Mana: 0 (0 untapped)</span>
    </div>
    <div class="row">
      <button class="primary" id="btnSetup">デモセットアップ</button>
      <button id="btnReset">リセット</button>
      <button id="btnEndTurn">ターン終了</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="panel">
    <h2>フィールド</h2>
    <div class="inner">

      <div class="panel" style="margin-bottom:12px">
        <h2>相手フィールド（P2：ミラー）</h2>
        <div class="inner">
          <div class="zoneTitle"><div style="font-weight:900">サポート・魔法</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="supportP2"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">インスタンス</div><div class="small">最大5（伏せ）</div></div>
          <div class="slotRow nowrap" id="instanceP2"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">ヒーロー（前衛/後衛）</div><div class="small">前後衛は可変（最低各1）</div></div>
          <div class="heroGrid" id="heroP2"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">モンスター</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="monsterP2"></div>
        </div>
      </div>

      <div class="panel">
        <h2>自分フィールド（P1）</h2>
        <div class="inner">
          <div class="zoneTitle"><div style="font-weight:900">モンスター</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="monsterP1"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">ヒーロー（前衛/後衛）</div><div class="small">入れ替え：1ターン1回/1マナ（戦闘不能は対象外）</div></div>
          <div class="heroGrid" id="heroP1"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">インスタンス</div><div class="small">最大5（相手から非公開）</div></div>
          <div class="slotRow nowrap" id="instanceP1"></div>
          <div class="hr"></div>

          <div class="zoneTitle"><div style="font-weight:900">サポート・魔法</div><div class="small">最大7</div></div>
          <div class="slotRow nowrap" id="supportP1"></div>

          <div class="hr"></div>
          <div class="zoneTitle"><div style="font-weight:900">手札（P1）</div><div class="small">クリックで詳細</div></div>
          <div class="slotRow nowrap" id="handP1"></div>
        </div>
      </div>

    </div>
  </div>

  <div class="panel">
    <h2>ログ</h2>
    <div class="inner">
      <textarea id="log" readonly></textarea>
      <div class="hr"></div>
      <div class="small">
        v27: ヒーロー前後衛（可変）・入れ替えUI（1ターン1回/1マナ）を実装。<br/>
        ※戦闘/効果/対象選択は次フェーズ。
      </div>
    </div>
  </div>
</div>

<div id="modalBackdrop">
  <div id="modal">
    <div class="modalHead">
      <div class="h" id="modalTitle">詳細</div>
      <button id="btnCloseModal">閉じる</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
  </div>
</div>

<script>
(() => {
  "use strict";
  const VERSION = "v27";
  const $ = (id) => document.getElementById(id);
  const esc = (s) => String(s ?? "").replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;", """:"&quot;","'":"&#39;" }[m]));
  const now = () => new Date().toLocaleTimeString();

  const dom = {
    jsStatus: $("jsStatus"),
    phaseChip: $("phaseChip"),
    turnChip: $("turnChip"),
    manaChip: $("manaChip"),
    btnSetup: $("btnSetup"),
    btnReset: $("btnReset"),
    btnEndTurn: $("btnEndTurn"),
    log: $("log"),
    monsterP1: $("monsterP1"),
    heroP1: $("heroP1"),
    instanceP1: $("instanceP1"),
    supportP1: $("supportP1"),
    handP1: $("handP1"),
    monsterP2: $("monsterP2"),
    heroP2: $("heroP2"),
    instanceP2: $("instanceP2"),
    supportP2: $("supportP2"),
    modalBackdrop: $("modalBackdrop"),
    modalTitle: $("modalTitle"),
    modalBody: $("modalBody"),
    btnCloseModal: $("btnCloseModal"),
  };

  function log(msg){
    dom.log.value += `[${now()}] ${msg}\n`;
    dom.log.scrollTop = dom.log.scrollHeight;
  }

  function normType(d){
    const t = String(d.cardType ?? d.type ?? "").toLowerCase();
    if(t === "magic" || t === "spell") return "SPELL";
    if(t === "support") return "SUPPORT";
    if(t === "monster") return "MONSTER";
    if(t === "hero") return "HERO";
    if(t === "instance") return "INSTANCE";
    const u = String(d.cardType ?? "").toUpperCase();
    if(["SPELL","SUPPORT","MONSTER","HERO","INSTANCE"].includes(u)) return u;
    return "UNKNOWN";
  }

  const Z = {
    MON: "monster",
    HERO_F: "heroFront",
    HERO_B: "heroBack",
    INST: "instance",
    SUP: "support",
    HAND: "hand",
    MANA: "mana",
  };

  function makeEmptyPlayer(){
    return {
      monster: new Array(7).fill(null),
      support: new Array(7).fill(null),
      instance: new Array(5).fill(null),
      heroFront: [],
      heroBack: [],
      hand: [],
      mana: [],
    };
  }

  function makeCardInst(id, owner){
    return {
      uid: `${owner}_${id}_${Math.random().toString(36).slice(2,9)}`,
      id, owner,
      faceDown: false,
      tapped: false,
      summonSick: false,
      _lp: null,
    };
  }

  const state = {
    defsById: new Map(),
    defsLoaded: false,
    turn: 1,
    active: "P1",
    phase: "MAIN",
    perTurn: {
      P1: { heroSwapUsed:false },
      P2: { heroSwapUsed:false },
    },
    players: {
      P1: makeEmptyPlayer(),
      P2: makeEmptyPlayer(),
    },
    heroSwap: { active:false, owner:"P1", fromRow:null, fromIndex:null },
  };

  function defOf(inst){ return inst ? (state.defsById.get(inst.id) ?? null) : null; }

  function manaAvailable(owner){
    return state.players[owner].mana.reduce((acc,c)=>acc + (!c.tapped ? 1 : 0), 0);
  }
  function manaTotal(owner){ return state.players[owner].mana.length; }
  function tapOneMana(owner){
    const c = state.players[owner].mana.find(x=>x && !x.tapped);
    if(!c) return false;
    c.tapped = true;
    return true;
  }
  function untapAllMana(owner){
    for(const c of state.players[owner].mana){ if(c) c.tapped=false; }
  }

  function isKnockedOut(heroInst){ return heroInst && Number(heroInst._lp ?? 0) <= 0; }

  async function loadDefs(){
    try{
      const url = new URL("cards.json", location.href);
      url.searchParams.set("t", Date.now());
      const res = await fetch(url.toString(), { cache:"no-store" });
      if(!res.ok) throw new Error("cards.json fetch failed: " + res.status);

      const data = await res.json();
      const arr = Array.isArray(data) ? data : (Array.isArray(data.cards) ? data.cards : null);
      if(!arr) throw new Error("cards.json format invalid (expected array or {cards:[...]})");

      const map = new Map();
      for(const d of arr){ if(d && d.id) map.set(d.id, d); }
      state.defsById = map;
      state.defsLoaded = true;
      log(`cards.json loaded (${map.size} cards)`);
    }catch(err){
      log("cards.json 読み込み失敗: " + (err?.message ?? String(err)));
      const fallback = [
        {id:"H_001", name:"フォールバックヒーロー", type:"hero", lp:5},
        {id:"M_001", name:"フォールバック兵", type:"monster", cost:1, atk:100, hp:200},
        {id:"SP_101", name:"フォールバック魔法", type:"magic", cost:1},
        {id:"SU_201", name:"フォールバック支援", type:"support", cost:1, lp:1},
        {id:"IN_301", name:"フォールバック・インスタンス", type:"instance"},
      ];
      state.defsById = new Map(fallback.map(x=>[x.id,x]));
    }
  }

  function resetGame(){
    state.turn = 1;
    state.active = "P1";
    state.phase = "MAIN";
    state.perTurn.P1.heroSwapUsed = false;
    state.perTurn.P2.heroSwapUsed = false;
    state.players.P1 = makeEmptyPlayer();
    state.players.P2 = makeEmptyPlayer();
    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    dom.log.value = "";
    log("リセットしました。");
    render();
  }

  function pickMany(filterFn, n){
    const out=[];
    for(const d of state.defsById.values()){
      if(filterFn(d)) out.push(d.id);
      if(out.length>=n) break;
    }
    return out;
  }

  function setupDemo(){
    resetGame();
    const heroIds = pickMany(d => normType(d)==="HERO", 4);
    const instIds = pickMany(d => normType(d)==="INSTANCE", 5);
    const monIds = pickMany(d => normType(d)==="MONSTER", 7);
    const supIds = pickMany(d => ["SUPPORT","SPELL"].includes(normType(d)), 7);

    const p1 = state.players.P1;
    for(let i=0;i<4;i++){
      const id = heroIds[i] ?? "H_001";
      const c = makeCardInst(id, "P1");
      const d = defOf(c);
      c._lp = Number(d?.lp ?? 5);
      if(i<2) p1.heroFront.push(c); else p1.heroBack.push(c);
    }

    const p2 = state.players.P2;
    for(let i=0;i<4;i++){
      const id = heroIds[(i+1)%Math.max(1,heroIds.length)] ?? "H_001";
      const c = makeCardInst(id, "P2");
      const d = defOf(c);
      c._lp = Number(d?.lp ?? 5);
      if(i<2) p2.heroFront.push(c); else p2.heroBack.push(c);
    }

    for(let i=0;i<5;i++){
      const c1 = makeCardInst(instIds[i] ?? "IN_301","P1"); c1.faceDown=true; p1.instance[i]=c1;
      const c2 = makeCardInst(instIds[(i+1)%Math.max(1,instIds.length)] ?? "IN_301","P2"); c2.faceDown=true; p2.instance[i]=c2;
    }

    const handPool = [...monIds, ...supIds, ...instIds].filter(Boolean);
    while(handPool.length<5){
      for(const d of state.defsById.values()){ handPool.push(d.id); if(handPool.length>=5) break; }
    }
    p1.hand = handPool.slice(0,5).map(id=>makeCardInst(id,"P1"));

    for(let i=0;i<2;i++){
      const id = p1.hand[i]?.id ?? (monIds[0] ?? "M_001");
      const c = makeCardInst(id,"P1"); p1.mana.push(c);
    }
    for(let i=0;i<2;i++){
      const id = monIds[i] ?? "M_001";
      const c = makeCardInst(id,"P2"); c.faceDown=true; p2.mana.push(c);
    }

    const om = makeCardInst(monIds[0] ?? "M_001","P2"); p2.monster[0]=om;
    const os = makeCardInst(supIds[0] ?? "SU_201","P2"); os.faceDown=true; p2.support[0]=os;

    log("デモセットアップ完了。");
    render();
  }

  function endTurn(){
    state.active = (state.active==="P1") ? "P2" : "P1";
    if(state.active==="P1") state.turn += 1;

    state.perTurn[state.active].heroSwapUsed = false;
    untapAllMana(state.active);

    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    log(`ターン終了 → Active=${state.active} / Turn=${state.turn}`);
    render();
  }

  function beginHeroSwap(owner, fromRow, fromIndex){
    if(owner !== state.active){ log("自分の手番ではありません。"); return; }
    if(owner !== "P1"){ log("プロトタイプではP1操作のみ"); return; }
    if(state.perTurn[owner].heroSwapUsed){ log("このターンは既に入れ替え済みです。"); return; }
    if(manaAvailable(owner) < 1){ log("マナ不足（入れ替えは1マナ）。"); return; }

    const p = state.players[owner];
    const src = (fromRow==="front") ? p.heroFront[fromIndex] : p.heroBack[fromIndex];
    if(!src) return;
    if(isKnockedOut(src)){ log("戦闘不能ヒーローは入れ替え不可。"); return; }

    state.heroSwap.active = true;
    state.heroSwap.owner = owner;
    state.heroSwap.fromRow = fromRow;
    state.heroSwap.fromIndex = fromIndex;
    log("入れ替え先（反対列）を選択してください。");
    render();
  }

  function completeHeroSwap(owner, toRow, toIndex){
    if(!state.heroSwap.active) return;
    if(owner !== state.heroSwap.owner) return;

    const fromRow = state.heroSwap.fromRow;
    const fromIndex = state.heroSwap.fromIndex;
    if(fromRow === toRow){ log("反対列のヒーローを選択してください。"); return; }

    const p = state.players[owner];
    const srcArr = (fromRow==="front") ? p.heroFront : p.heroBack;
    const dstArr = (toRow==="front") ? p.heroFront : p.heroBack;
    const a = srcArr[fromIndex];
    const b = dstArr[toIndex];
    if(!a || !b) return;
    if(isKnockedOut(a) || isKnockedOut(b)){ log("戦闘不能ヒーローとの入れ替えは不可。"); return; }

    if(manaAvailable(owner) < 1 || !tapOneMana(owner)){ log("マナ消費に失敗しました。"); return; }

    srcArr[fromIndex] = b;
    dstArr[toIndex] = a;
    state.perTurn[owner].heroSwapUsed = true;

    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    log("ヒーローを入れ替えました（1マナ消費）。");
    render();
  }

  function cancelHeroSwap(){
    if(!state.heroSwap.active) return;
    state.heroSwap = { active:false, owner:"P1", fromRow:null, fromIndex:null };
    log("入れ替えをキャンセルしました。");
    render();
  }

  function updateTop(){
    dom.phaseChip.textContent = `PHASE: ${state.phase}`;
    dom.turnChip.textContent = `TURN: ${state.turn} / Active: ${state.active}`;
    dom.manaChip.textContent = `P1 Mana: ${manaTotal("P1")} (${manaAvailable("P1")} untapped) / SwapUsed:${state.perTurn.P1.heroSwapUsed?"Y":"N"}`;
  }

  function cardLabel(inst, viewer){
    const d = defOf(inst);
    if(!d) return {name: inst.id, meta:"", badges:[]};
    const type = normType(d);
    const facedown = (viewer !== inst.owner) && inst.faceDown;

    if(facedown){
      if(type==="INSTANCE") return {name:"インスタンス（伏せ）", meta:"", badges:[{t:"伏せ", cls:"info"}]};
      return {name:"（伏せ）", meta:"", badges:[{t:"伏せ", cls:"info"}]};
    }

    const badges=[];
    if(type==="HERO") badges.push({t:"HERO", cls:"info"});
    if(type==="MONSTER") badges.push({t:(d.subType??"").toString(), cls:"info"});
    if(type==="SUPPORT") badges.push({t:"SUP", cls:"info"});
    if(type==="SPELL") badges.push({t:"MAG", cls:"info"});
    if(type==="INSTANCE") badges.push({t:"INST", cls:"info"});
    if(type==="HERO" && isKnockedOut(inst)) badges.push({t:"戦闘不能", cls:"bad"});

    let meta="";
    if(type==="HERO") meta = `LP:${inst._lp ?? (d.lp ?? "-")}`;
    else if(type==="MONSTER") meta = `Cost:${d.cost??0} / ATK:${d.atk??"-"} / HP:${d.hp??"-"}`;
    else if(type==="SUPPORT") meta = `Cost:${d.cost??0} / LP:${d.lp??1}`;
    else if(type==="SPELL") meta = `Cost:${d.cost??0}`;
    else if(type==="INSTANCE") meta = "（デュエル中1回）";

    return {name:d.name ?? inst.id, meta, badges};
  }

  function renderSlotsRow(container, arr, viewer, zoneKey){
    container.innerHTML="";
    for(let i=0;i<arr.length;i++){
      const inst = arr[i];
      if(!inst){
        const ph=document.createElement("div"); ph.className="slot"; ph.textContent="—"; container.appendChild(ph); continue;
      }
      const lbl = cardLabel(inst, viewer);
      const el=document.createElement("div"); el.className="card";
      el.addEventListener("click", ()=>openCardDetails({owner:inst.owner, zone:zoneKey, index:i}));

      const badges=document.createElement("div"); badges.className="badges";
      for(const b of lbl.badges){
        const be=document.createElement("span"); be.className="badge "+(b.cls||""); be.textContent=b.t; badges.appendChild(be);
      }
      el.appendChild(badges);

      const nm=document.createElement("div"); nm.className="name"; nm.textContent=lbl.name; el.appendChild(nm);
      const meta=document.createElement("div"); meta.className="meta"; meta.textContent=lbl.meta; el.appendChild(meta);
      container.appendChild(el);
    }
  }

  function renderHeroGrid(container, owner, viewer){
    const p = state.players[owner];
    container.innerHTML="";

    const frontLabel=document.createElement("div");
    frontLabel.className="heroRowLabel";
    frontLabel.innerHTML = `<span>前衛（${p.heroFront.length}）</span><span class="small">最低1</span>`;
    const frontRow=document.createElement("div"); frontRow.className="heroRow";

    const backLabel=document.createElement("div");
    backLabel.className="heroRowLabel";
    backLabel.innerHTML = `<span>後衛（${p.heroBack.length}）</span><span class="small">最低1</span>`;
    const backRow=document.createElement("div"); backRow.className="heroRow";

    container.appendChild(frontLabel); container.appendChild(frontRow);
    container.appendChild(backLabel); container.appendChild(backRow);

    function heroCard(inst, rowName, idx){
      const lbl = cardLabel(inst, viewer);
      const el=document.createElement("div"); el.className="card";

      const swapMode = state.heroSwap.active && owner===state.heroSwap.owner;
      if(swapMode){
        if(state.heroSwap.fromRow===rowName && state.heroSwap.fromIndex===idx){
          el.classList.add("swapSource");
        }else if(rowName !== state.heroSwap.fromRow && !isKnockedOut(inst)){
          el.classList.add("selectable");
          el.addEventListener("click", (ev)=>{ ev.stopPropagation(); completeHeroSwap(owner, rowName, idx); });
        }
      }
      if(!swapMode || (swapMode && (rowName===state.heroSwap.fromRow && idx===state.heroSwap.fromIndex))){
        el.addEventListener("click", ()=>openCardDetails({owner:inst.owner, zone:(rowName==="front"?Z.HERO_F:Z.HERO_B), index:idx}));
      }

      const badges=document.createElement("div"); badges.className="badges";
      for(const b of lbl.badges){
        const be=document.createElement("span"); be.className="badge "+(b.cls||""); be.textContent=b.t; badges.appendChild(be);
      }
      el.appendChild(badges);

      const nm=document.createElement("div"); nm.className="name"; nm.textContent=lbl.name; el.appendChild(nm);
      const meta=document.createElement("div"); meta.className="meta"; meta.textContent=lbl.meta; el.appendChild(meta);

      if(inst.owner==="P1"){
        const actions=document.createElement("div"); actions.className="cardActions";
        const swapBtn=document.createElement("button");
        swapBtn.className="miniBtn swap";
        swapBtn.textContent = state.heroSwap.active ? "キャンセル" : "入れ替え";
        swapBtn.disabled = (inst.owner!==state.active) || isKnockedOut(inst) || state.perTurn.P1.heroSwapUsed || manaAvailable("P1")<1;
        swapBtn.addEventListener("click", (ev)=>{
          ev.stopPropagation();
          if(state.heroSwap.active) cancelHeroSwap();
          else beginHeroSwap("P1", rowName, idx);
        });
        actions.appendChild(swapBtn);
        el.appendChild(actions);
      }
      return el;
    }

    if(p.heroFront.length===0){
      const ph=document.createElement("div"); ph.className="slot"; ph.textContent="（前衛なし）"; frontRow.appendChild(ph);
    }else{
      p.heroFront.forEach((inst,i)=>frontRow.appendChild(heroCard(inst,"front",i)));
    }

    if(p.heroBack.length===0){
      const ph=document.createElement("div"); ph.className="slot"; ph.textContent="（後衛なし）"; backRow.appendChild(ph);
    }else{
      p.heroBack.forEach((inst,i)=>backRow.appendChild(heroCard(inst,"back",i)));
    }
  }

  function renderHand(){
    dom.handP1.innerHTML="";
    const p1=state.players.P1;
    const max=Math.max(7,p1.hand.length);
    for(let i=0;i<max;i++){
      const inst=p1.hand[i];
      if(!inst){ const ph=document.createElement("div"); ph.className="slot"; ph.textContent="—"; dom.handP1.appendChild(ph); continue; }
      const lbl=cardLabel(inst,"P1");
      const el=document.createElement("div"); el.className="card";
      el.addEventListener("click", ()=>openCardDetails({owner:"P1", zone:Z.HAND, index:i}));

      const badges=document.createElement("div"); badges.className="badges";
      for(const b of lbl.badges){
        const be=document.createElement("span"); be.className="badge "+(b.cls||""); be.textContent=b.t; badges.appendChild(be);
      }
      el.appendChild(badges);
      const nm=document.createElement("div"); nm.className="name"; nm.textContent=lbl.name; el.appendChild(nm);
      const meta=document.createElement("div"); meta.className="meta"; meta.textContent=lbl.meta; el.appendChild(meta);
      dom.handP1.appendChild(el);
    }
  }

  function render(){
    updateTop();

    renderSlotsRow(dom.supportP2, state.players.P2.support, "P1", Z.SUP);
    renderSlotsRow(dom.instanceP2, state.players.P2.instance.map(x=>x?({...x,faceDown:true}):null), "P1", Z.INST);
    renderHeroGrid(dom.heroP2, "P2", "P1");
    renderSlotsRow(dom.monsterP2, state.players.P2.monster, "P1", Z.MON);

    renderSlotsRow(dom.monsterP1, state.players.P1.monster, "P1", Z.MON);
    renderHeroGrid(dom.heroP1, "P1", "P1");
    renderSlotsRow(dom.instanceP1, state.players.P1.instance.map(x=>x?({...x,faceDown:true}):null), "P1", Z.INST);
    renderSlotsRow(dom.supportP1, state.players.P1.support, "P1", Z.SUP);
    renderHand();
  }

  function openModal(title, bodyHtml){
    dom.modalTitle.textContent=title;
    dom.modalBody.innerHTML=bodyHtml;
    dom.modalBackdrop.style.display="flex";
  }
  function closeModal(){
    dom.modalBackdrop.style.display="none";
    dom.modalBody.innerHTML="";
  }

  function getHeroByZoneIndex(owner, zone, index){
    const p=state.players[owner];
    if(zone===Z.HERO_F) return p.heroFront[index] ?? null;
    if(zone===Z.HERO_B) return p.heroBack[index] ?? null;
    return null;
  }

  function openCardDetails(ref){
    const {owner, zone, index} = ref;
    const p=state.players[owner];
    let inst=null;
    if(zone===Z.HAND) inst=p.hand[index];
    else if(zone===Z.MON) inst=p.monster[index];
    else if(zone===Z.SUP) inst=p.support[index];
    else if(zone===Z.INST) inst=p.instance[index];
    else if(zone===Z.HERO_F || zone===Z.HERO_B) inst=getHeroByZoneIndex(owner, zone, index);
    if(!inst) return;

    const d=defOf(inst);
    const type=d?normType(d):"UNKNOWN";
    const facedown = (owner!=="P1") && inst.faceDown;

    const header = facedown ? "（伏せカード）" : (d?.name ?? inst.id);
    const meta = facedown ? "" : `${type} / Cost:${d?.cost ?? 0}`;
    let stats="";
    if(!facedown){
      if(type==="MONSTER") stats=`ATK:${d?.atk ?? "-"} / HP:${d?.hp ?? "-"}`;
      if(type==="HERO") stats=`LP:${inst._lp ?? (d?.lp ?? "-")}`;
      if(type==="SUPPORT") stats=`LP:${d?.lp ?? 1}`;
    }
    const text = facedown ? "" : (d?.text ?? "");

    let heroControls = "";
    if(type==="HERO" && inst.owner==="P1"){
      const rowName = (zone===Z.HERO_F) ? "front" : "back";
      const swapDisabled = (inst.owner!==state.active) || isKnockedOut(inst) || state.perTurn.P1.heroSwapUsed || manaAvailable("P1")<1;
      heroControls = `
        <div class="hr"></div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="primary" ${swapDisabled?"disabled":""} data-act="beginSwap" data-row="${rowName}" data-idx="${index}">入れ替え開始（1マナ）</button>
          <button ${state.heroSwap.active?"":"disabled"} data-act="cancelSwap">入れ替えキャンセル</button>
          <button data-act="testKO">（テスト）LP=0</button>
          <button data-act="testHeal">（テスト）LP+2</button>
        </div>
        <div class="small">※戦闘不能（LP=0）は入れ替え不可。回復で復帰します。</div>
      `;
    }

    openModal(header, `
      <div class="small">${esc(meta)}</div>
      <div class="hr"></div>
      <div>${esc(stats)}</div>
      <div class="hr"></div>
      <div class="small">${esc(text)}</div>
      ${heroControls}
      <div class="hr"></div>
      <div class="small">Owner:${esc(inst.owner)} / Zone:${esc(zone)} / Index:${index}</div>
    `);

    dom.modalBody.querySelectorAll("[data-act]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const act=btn.getAttribute("data-act");
        if(act==="beginSwap"){
          const row=btn.getAttribute("data-row");
          const idx=Number(btn.getAttribute("data-idx"));
          closeModal();
          beginHeroSwap("P1", row, idx);
        }else if(act==="cancelSwap"){
          cancelHeroSwap();
          closeModal();
        }else if(act==="testKO"){
          inst._lp = 0;
          inst.tapped = true;
          log("（テスト）ヒーローを戦闘不能にしました。");
          render();
          closeModal();
        }else if(act==="testHeal"){
          inst._lp = Math.max(0, Number(inst._lp ?? 0) + 2);
          if(inst._lp > 0) inst.tapped = false;
          log("（テスト）ヒーローを回復しました。");
          render();
          closeModal();
        }
      });
    });
  }

  function bind(){
    dom.btnSetup.addEventListener("click", setupDemo);
    dom.btnReset.addEventListener("click", resetGame);
    dom.btnEndTurn.addEventListener("click", endTurn);

    dom.btnCloseModal.addEventListener("click", closeModal);
    dom.modalBackdrop.addEventListener("click", (e)=>{ if(e.target===dom.modalBackdrop) closeModal(); });

    window.addEventListener("keydown", (e)=>{
      if(e.key==="Escape"){
        if(state.heroSwap.active) cancelHeroSwap();
        closeModal();
      }
    });
  }

  async function init(){
    dom.jsStatus.style.background = "var(--good)";
    dom.jsStatus.textContent = `JS ready (${VERSION})`;
    bind();
    await loadDefs();
    render();
  }

  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", init, {once:true});
  }else{
    init();
  }
})();
</script>
</body>
</html>
