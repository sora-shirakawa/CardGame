<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Card Game Prototype — v25</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(255,255,255,.06);
    --line:rgba(255,255,255,.12);
    --text:rgba(255,255,255,.92);
    --muted:rgba(255,255,255,.70);
    --good:#14532d;
    --warn:#7c2d12;
    --bad:#7f1d1d;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 40% -10%, rgba(125,211,252,.16), transparent),
      radial-gradient(900px 600px at 90% 10%, rgba(250,204,21,.10), transparent),
      var(--bg);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
  }
  header{
    position:sticky;top:0;z-index:50;
    backdrop-filter: blur(10px);
    background:linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.68));
    border-bottom:1px solid var(--line);
  }
  #jsStatus{
    background:var(--bad);
    color:#fff;
    padding:10px 12px;
    font-weight:900;
    font-size:13px;
    border-bottom:1px solid rgba(255,255,255,.12);
  }
  .bar{
    display:flex;gap:10px;align-items:center;justify-content:space-between;
    padding:10px 12px; flex-wrap:wrap
  }
  .title{font-weight:900}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .chip{
    display:inline-flex;align-items:center;gap:6px;
    padding:5px 10px;border-radius:999px;
    background:rgba(255,255,255,.10);border:1px solid var(--line);
    font-size:12px
  }
  button{
    appearance:none;border:1px solid var(--line);
    background:var(--panel);color:var(--text);
    padding:9px 12px;border-radius:12px;font-weight:800;cursor:pointer
  }
  button:disabled{opacity:.45;cursor:not-allowed}
  button.primary{border-color:rgba(125,211,252,.35); box-shadow:0 0 0 1px rgba(125,211,252,.06) inset}
  .wrap{
    display:grid;grid-template-columns: 1fr;
    gap:12px; padding:12px; max-width:1100px; margin:0 auto
  }
  .panel{
    background:var(--panel); border:1px solid var(--line);
    border-radius:var(--radius); box-shadow: var(--shadow);
  }
  .panel h2{margin:0;padding:12px 12px 0 12px;font-size:14px;opacity:.95}
  .panel .inner{padding:12px}
  .hr{height:1px;background:var(--line);margin:10px 0}

  .slotRow{display:flex;gap:10px;flex-wrap:wrap}
  .slotRow.nowrap{flex-wrap:nowrap;overflow-x:auto;padding-bottom:6px}
  .slotRow.nowrap::-webkit-scrollbar{height:8px}
  .slotRow.nowrap::-webkit-scrollbar-thumb{background:rgba(255,255,255,.18);border-radius:999px}
  .slotRow.nowrap::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px}

  .slot{
    width:170px; min-width:170px;
    height:92px;
    border-radius:14px;
    border:1px dashed rgba(255,255,255,.18);
    display:flex;align-items:center;justify-content:center;
    color:rgba(255,255,255,.55);
    background:rgba(255,255,255,.03);
    position:relative;
    cursor:pointer;
    padding:8px;
  }
  .slot.fill{border-style:solid;background:rgba(255,255,255,.05)}
  .slot .name{font-weight:900;font-size:13px;line-height:1.2;text-align:center}
  .slot .meta{margin-top:6px;font-size:12px;color:var(--muted);line-height:1.2;text-align:center}
  .badges{position:absolute;top:6px;right:6px;display:flex;gap:6px;flex-wrap:wrap;justify-content:flex-end}
  .badge{font-size:11px;padding:3px 8px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid var(--line)}
  .badge.warn{background:rgba(124,45,18,.35);border-color:rgba(124,45,18,.6)}
  .badge.info{background:rgba(29,78,216,.20);border-color:rgba(29,78,216,.45)}

  .handRow{display:flex;gap:10px;flex-wrap:nowrap;overflow-x:auto;padding-bottom:6px}
  .card{
    width:170px; min-width:170px;
    background:linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,.04));
    border:1px solid var(--line); border-radius:14px; padding:10px;
    cursor:pointer; position:relative
  }
  .card .name{font-weight:900;font-size:13px;line-height:1.2}
  .card .meta{margin-top:6px;font-size:12px;color:var(--muted);line-height:1.3}
  .small{font-size:12px;color:var(--muted)}
  pre{white-space:pre-wrap;word-break:break-word;margin:0}

  /* modal */
  #modalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:100}
  #modalDialog{width:min(860px, 94vw); max-height: 90vh; overflow:auto; background:rgba(12,18,36,.92); border:1px solid var(--line);
          border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.6)}
  .modalHead{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px;border-bottom:1px solid var(--line)}
  .modalHead .h{font-weight:900}
  .modalBody{padding:12px}
  .actionsRow{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
<div id="jsStatus">JS未起動（v25）</div>

<header>
  <div class="bar">
    <div class="row">
      <div class="title">Card Game Prototype — <span id="verLabel">v24</span></div>
      <span class="chip">Phase: <b id="phaseLabel">-</b></span>
      <span class="chip">Turn: <b id="turnLabel">-</b></span>
      <span class="chip">Active: <b id="activeLabel">-</b></span>
    </div>
    <div class="row">
      <button id="btnSetup" class="primary">デモセットアップ</button>
      <button id="btnPhase">フェイズ</button>
      <button id="btnEndTurn">ターン終了</button>
      <button id="btnReset">リセット</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="panel">
    <h2>相手フィールド（常時表示・ミラー）</h2>
    <div class="inner">
      <div class="small">奥→手前：サポート・魔法 → インスタンス → ヒーロー → モンスター</div>
      <div class="hr"></div>
      <div class="small">サポート・魔法ゾーン（相手）</div>
      <div id="supportSlotsP2" class="slotRow nowrap"></div>
      <div class="hr"></div>
      <div class="small">インスタンスゾーン（相手）</div>
      <div id="instanceSlotsP2" class="slotRow nowrap"></div>
      <div class="hr"></div>
      <div class="small">ヒーローゾーン（相手）</div>
      <div id="heroSlotsP2" class="slotRow nowrap"></div>
      <div class="hr"></div>
      <div class="small">モンスターゾーン（相手）</div>
      <div id="monsterSlotsP2" class="slotRow nowrap"></div>
    </div>
  </div>

  <div class="panel">
    <h2>自分フィールド</h2>
    <div class="inner">
      <div class="small">モンスター/サポートは最大7枠・横並び（小画面は横スクロール）</div>
      <div class="hr"></div>
      <div class="small">モンスターゾーン（自分）</div>
      <div id="monsterSlotsP1" class="slotRow nowrap"></div>
      <div class="hr"></div>
      <div class="small">ヒーローゾーン（自分）</div>
      <div id="heroSlotsP1" class="slotRow nowrap"></div>
      <div class="hr"></div>
      <div class="small">インスタンスゾーン（自分）</div>
      <div id="instanceSlotsP1" class="slotRow nowrap"></div>
      <div class="hr"></div>
      <div class="small">サポート・魔法ゾーン（自分）</div>
      <div id="supportSlotsP1" class="slotRow nowrap"></div>
      <div class="hr"></div>
      <div class="small">手札（自分）</div>
      <div id="handRow" class="handRow"></div>
    </div>
  </div>

  <div class="panel">
    <h2>ログ</h2>
    <div class="inner">
      <pre id="log" class="small"></pre>
    </div>
  </div>
</div>

<div id="modalBackdrop">
  <div id="modalDialog">
    <div class="modalHead">
      <div class="h" id="modalTitle">-</div>
      <button id="btnCloseModal">閉じる</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
  </div>
</div>

<script>
(() => {
  "use strict";
  const VERSION = "v25";

  const $ = (id) => document.getElementById(id);
  const esc = (s) => String(s ?? "").replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;", '"':"&quot;","'":"&#39;" }[m]));

  const jsStatus = $("jsStatus");
  jsStatus.textContent = `JS起動（${VERSION}）`;
  jsStatus.style.background = "var(--good)";

  const PHASES = ["DRAW","MAIN","BATTLE","END"];
  const Z = { MON:"monster", HERO:"hero", INST:"instance", SUP:"support", HAND:"hand", MANA:"mana", GRAVE:"grave" };

  function log(msg){
    const el = $("log");
    if(!el) return;
    el.textContent = (el.textContent + msg + "\n").slice(-10000);
    el.scrollTop = el.scrollHeight;
  }

  function makeEmptyPlayer(){
    return {
      monster: Array(7).fill(null),
      hero: Array(4).fill(null),
      instance: Array(5).fill(null),
      support: Array(7).fill(null),
      hand: [],
      mana: [],
      grave: [],
    };
  }

  function makeCardInst(id, owner){
    return {
      uid: `${id}__${Math.random().toString(36).slice(2,9)}`,
      id, owner,
      zone: Z.HAND,
      faceDown:false,
      tapped:false,
      summonSick:false,
      _lp:null,
    };
  }

  const state = {
    defsById: new Map(),
    defsLoaded: false,
    turn: 1,
    active: "P1",
    phase: "MAIN",
    perTurn: { P1:{manaSet:false}, P2:{manaSet:false} },
    players: { P1: makeEmptyPlayer(), P2: makeEmptyPlayer() },
  };

  function normalizeType(raw){
    const t = String(raw?.cardType ?? raw?.type ?? raw?.card_type ?? "").trim().toUpperCase();
    const base = t.split(/[\/\s]/)[0];
    if(base === "MONSTER" || base === "MONSTER".toLowerCase().toUpperCase()) return "MONSTER";
    if(base === "HERO") return "HERO";
    if(base === "INSTANCE") return "INSTANCE";
    if(base === "SUPPORT") return "SUPPORT";
    if(base === "SPELL") return "SPELL";
    if(base === "魔法") return "SPELL";
    if(base === "サポート") return "SUPPORT";
    return base || "UNKNOWN";
  }

  function normalizeDef(raw){
    const id = raw?.id ?? raw?.cardId ?? raw?.card_id ?? raw?.ID ?? null;
    if(!id) return null;
    const cardType = normalizeType(raw);
    return {
      id: String(id),
      name: raw?.name ?? raw?.title ?? String(id),
      cardType,
      subType: raw?.subType ?? raw?.subtype ?? raw?.rarityType ?? "",
      cost: Number(raw?.cost ?? 0),
      atk: (raw?.atk ?? raw?.ATK ?? null),
      hp: (raw?.hp ?? raw?.HP ?? null),
      lp: (raw?.lp ?? raw?.LP ?? raw?.life ?? null),
      text: raw?.text ?? raw?.effectText ?? "",
      effect: raw?.effect ?? null,
      _raw: raw,
    };
  }

  async function loadDefs(){
    const url = `cards.json?t=${Date.now()}`;
    try{
      const res = await fetch(url, { cache:"no-store" });
      if(!res.ok) throw new Error(`cards.json fetch failed: ${res.status}`);
      const json = await res.json();

      let arr = null;
      if(Array.isArray(json)) arr = json;
      else if(Array.isArray(json?.cards)) arr = json.cards;
      else if(Array.isArray(json?.data)) arr = json.data;

      if(!arr) throw new Error("cards.json format unsupported (need array or {cards:[...]})");

      const map = new Map();
      for(const raw of arr){
        const d = normalizeDef(raw);
        if(!d) continue;
        map.set(d.id, d);
      }
      
      // Ensure fallback defs exist even when custom cards.json doesn't include them
      const fallbackDefs = [
        {id:"m_fallback_1", name:"フォールバック兵", cardType:"MONSTER", subType:"S", cost:1, atk:100, hp:200, text:""},
        {id:"sp_fallback_1", name:"フォールバック魔法", cardType:"SPELL", cost:1, effect:{kind:"damage", amount:100, target:"opponentHero"}, text:""},
        {id:"su_fallback_1", name:"フォールバック支援", cardType:"SUPPORT", cost:1, lp:1, text:""},
        {id:"h_fallback_1", name:"フォールバックヒーロー", cardType:"HERO", lp:800, text:""},
        {id:"i_fallback_1", name:"フォールバック・インスタンス", cardType:"INSTANCE", text:""},
      ];
      for(const fd of fallbackDefs){
        if(fd && fd.id && !map.has(fd.id)) map.set(fd.id, fd);
      }

      state.defsById = map;
      state.defsLoaded = true;
      log(`cards.json loaded (${map.size} cards)`);
      return true;
    }catch(err){
      state.defsLoaded = false;
      log(`cards.json 読み込み失敗: ${err?.message ?? String(err)} / フォールバックで起動します。`);
      const fallback = [
        {id:"M_001", name:"フォールバック兵", cardType:"MONSTER", subType:"S", cost:1, atk:100, hp:200, text:"（効果なし）"},
        {id:"SP_001", name:"フォールバック魔法", cardType:"SPELL", cost:1, effect:{kind:"damage", amount:100, target:"opponentHero"}, text:""},
        {id:"SU_001", name:"フォールバック支援", cardType:"SUPPORT", cost:1, lp:1, text:""},
        {id:"H_001", name:"フォールバックヒーロー", cardType:"HERO", lp:800, text:""},
        {id:"I_001", name:"フォールバック・インスタンス", cardType:"INSTANCE", text:""},
      ];
      state.defsById = new Map(fallback.map(x => [x.id, x]));
      return false;
    }
  }

  function defOf(inst){
    return inst ? (state.defsById.get(inst.id) || null) : null;
  }

  function manaAvailable(owner){
    return state.players[owner].mana.filter(c => c && !c.tapped).length;
  }
  function tapMana(owner, n){
    const p = state.players[owner];
    let need = n;
    for(const c of p.mana){
      if(need<=0) break;
      if(!c.tapped){ c.tapped = true; need--; }
    }
    return need===0;
  }
  function untapAllMana(owner){
    for(const c of state.players[owner].mana){ c.tapped = false; }
  }

  function resetGame(){
    state.turn = 1;
    state.active = "P1";
    state.phase = "MAIN";
    state.perTurn = { P1:{manaSet:false}, P2:{manaSet:false} };
    state.players = { P1: makeEmptyPlayer(), P2: makeEmptyPlayer() };
    closeModal();
    log("リセットしました。");
    render();
  }

  function pickMany(predicate, n){
    const out = [];
    for(const d of state.defsById.values()){
      if(predicate(d)) out.push(d.id);
      if(out.length>=n) break;
    }
    return out;
  }

  function setupDemo(){
    resetGame();

    const heroIds = pickMany(d => d.cardType==="HERO", 4);
    const instIds = pickMany(d => d.cardType==="INSTANCE", 5);
    const monIds  = pickMany(d => d.cardType==="MONSTER", 10);
    const supIds  = pickMany(d => d.cardType==="SUPPORT" || d.cardType==="SPELL", 10);

    for(let i=0;i<4;i++){
      const id = heroIds[i] || "H_001";
      const c = makeCardInst(id, "P1"); c.zone = Z.HERO;
      state.players.P1.hero[i] = c;
    }
    for(let i=0;i<5;i++){
      const id = instIds.length ? instIds[i % instIds.length] : (pickByType("INSTANCE") || "i_fallback_1");
      const c = makeCardInst(id, "P1");
      c.zone = Z.INST;
      c.faceDown = true;
      state.players.P1.instance[i] = c;
    }

    for(let i=0;i<4;i++){
      const id = heroIds[(i+1)%heroIds.length] || "H_001";
      const c = makeCardInst(id, "P2"); c.zone = Z.HERO;
      state.players.P2.hero[i] = c;
    }
    for(let i=0;i<5;i++){
      const id = instIds.length ? instIds[(i+1) % instIds.length] : (pickByType("INSTANCE") || "i_fallback_1");
      const c = makeCardInst(id, "P2");
      c.zone = Z.INST;
      c.faceDown = true; // opponent instance always facedown
      state.players.P2.instance[i] = c;
    }

    const handIds = [...monIds.slice(0,3), ...supIds.slice(0,3)];
    while(handIds.length < 5) handIds.push(monIds[handIds.length] || supIds[handIds.length] || "M_001");
    state.players.P1.hand = handIds.slice(0,5).map(id => { const c = makeCardInst(id, "P1"); c.zone = Z.HAND; return c; });

    for(let i=0;i<2;i++){
      const id = monIds[i] || "M_001";
      const c = makeCardInst(id, "P1"); c.zone = Z.MANA;
      state.players.P1.mana.push(c);
    }
    for(let i=0;i<2;i++){
      const id = monIds[(i+2)%monIds.length] || "M_001";
      const c = makeCardInst(id, "P2"); c.zone = Z.MANA; c.faceDown = true;
      state.players.P2.mana.push(c);
    }

    if(monIds[0]){
      const om = makeCardInst(monIds[0], "P2"); om.zone = Z.MON;
      state.players.P2.monster[0] = om;
    }
    if(supIds[0]){
      const os = makeCardInst(supIds[0], "P2"); os.zone = Z.SUP; os.faceDown = true;
      state.players.P2.support[0] = os;
    }

    log("デモセットアップ完了。");
    render();
  }

  function endTurn(){
    state.phase = "END";
    state.active = (state.active==="P1") ? "P2" : "P1";
    if(state.active==="P1") state.turn += 1;

    state.perTurn[state.active].manaSet = false;
    untapAllMana(state.active);

    for(const c of state.players[state.active].monster){
      if(c) c.summonSick = false;
    }

    state.phase = "DRAW";
    log(`ターン交代: Active=${state.active} / Turn=${state.turn}`);
    render();
  }

  function setPhase(p){
    if(!PHASES.includes(p)) return;
    state.phase = p;
    log(`フェイズ: ${p}`);
    render();
  }

  function moveToGrave(inst){
    const p = state.players[inst.owner];
    inst.zone = Z.GRAVE;
    inst.faceDown = false;
    inst.tapped = false;
    inst.summonSick = false;
    p.grave.push(inst);
  }

  function actToMana(ref){
    const {owner, zone, index} = ref;
    if(owner !== state.active){ log("自分の手番ではありません。"); return; }
    if(zone !== Z.HAND){ log("手札からのみマナ化できます。"); return; }
    if(state.perTurn[owner].manaSet){ log("このターンは既にマナ化しました。"); return; }

    const p = state.players[owner];
    const inst = p.hand[index];
    if(!inst) return;

    p.hand.splice(index,1);
    inst.zone = Z.MANA;
    inst.tapped = false;
    p.mana.push(inst);
    state.perTurn[owner].manaSet = true;
    log(`マナへ: ${defOf(inst)?.name ?? inst.id}`);
    render();
  }

  function actSummon(ref){
    const {owner, zone, index} = ref;
    if(owner !== state.active){ log("自分の手番ではありません。"); return; }
    if(zone !== Z.HAND){ log("召喚は手札からのみ。"); return; }
    if(state.phase !== "MAIN"){ log("召喚はMAINのみ。"); return; }

    const p = state.players[owner];
    const inst = p.hand[index];
    if(!inst) return;
    const d = defOf(inst);
    if(!d){ log("カード定義不明。"); return; }
    if(d.cardType !== "MONSTER"){ log("モンスター以外は召喚できません。"); return; }

    const cost = Number(d.cost||0);
    if(manaAvailable(owner) < cost){ log(`マナ不足（必要${cost} / 残${manaAvailable(owner)}）。`); return; }
    const slot = p.monster.findIndex(x => !x);
    if(slot < 0){ log("モンスターゾーンが満杯です。"); return; }

    tapMana(owner, cost);
    p.hand.splice(index,1);
    inst.zone = Z.MON;
    inst.summonSick = true;
    p.monster[slot] = inst;

    log(`召喚: ${d.name}（Cost${cost}） -> スロット${slot+1}（召喚酔い）`);
    render();
  }

  function actSet(ref){
    const {owner, zone, index} = ref;
    if(owner !== state.active){ log("自分の手番ではありません。"); return; }
    if(zone !== Z.HAND){ log("セットは手札からのみ。"); return; }
    if(state.phase !== "MAIN"){ log("セットはMAINのみ。"); return; }

    const p = state.players[owner];
    const inst = p.hand[index];
    if(!inst) return;
    const d = defOf(inst);
    if(!d){ log("カード定義不明。"); return; }

    if(!(d.cardType==="SPELL" || d.cardType==="SUPPORT")){ log("魔法/サポートのみセット可能。"); return; }

    const cost = Number(d.cost||0);
    if(manaAvailable(owner) < cost){ log(`マナ不足（必要${cost} / 残${manaAvailable(owner)}）。`); return; }

    const slot = p.support.findIndex(x => !x);
    if(slot < 0){ log("サポート・魔法ゾーンが満杯です。"); return; }

    tapMana(owner, cost);
    p.hand.splice(index,1);
    inst.zone = Z.SUP;
    inst.faceDown = true;
    p.support[slot] = inst;

    log(`セット: ${d.name}（Cost${cost}） -> スロット${slot+1}`);
    render();
  }

  function applyDamageEffect(owner, effect){
    const amount = Number(effect?.amount ?? 0);
    const opp = (owner==="P1") ? "P2" : "P1";
    const ph = state.players[opp].hero;
    const tgtIdx = ph.findIndex(x => !!x);
    if(tgtIdx < 0){ log("相手ヒーローがいません。"); return; }
    const tgt = ph[tgtIdx];
    const d = defOf(tgt);
    if(tgt._lp == null) tgt._lp = Number(d?.lp ?? 800);
    tgt._lp = Math.max(0, tgt._lp - amount);
    log(`→ 相手ヒーローに${amount}ダメージ（残LP:${tgt._lp}）`);
  }

  function actActivate(ref){
    const {owner, zone, index} = ref;
    if(owner !== state.active){ log("自分の手番ではありません。"); return; }

    const p = state.players[owner];
    let inst = null;
    if(zone===Z.HAND) inst = p.hand[index];
    else if(zone===Z.SUP) inst = p.support[index];
    else if(zone===Z.INST) inst = p.instance[index];
    else if(zone===Z.HERO) inst = p.hero[index];
    else { log("この領域からは発動できません。"); return; }

    if(!inst) return;
    const d = defOf(inst);
    if(!d){ log("カード定義不明。"); return; }

    if(d.cardType==="MONSTER"){ log("（モンスター効果は後で実装）"); return; }
    if(d.cardType==="HERO"){ log(`ヒーロー効果: ${d.name}（未実装）`); return; }

    if(d.cardType==="INSTANCE"){
      log(`インスタンス発動: ${d.name}（未実装）`);
      p.instance[index] = null;
      moveToGrave(inst);
      render();
      return;
    }

    if(d.cardType==="SPELL" || d.cardType==="SUPPORT"){
      const cost = Number(d.cost||0);
      if(manaAvailable(owner) < cost){ log(`マナ不足（必要${cost} / 残${manaAvailable(owner)}）。`); return; }
      tapMana(owner, cost);

      if(zone===Z.HAND) p.hand.splice(index,1);
      if(zone===Z.SUP) p.support[index] = null;

      inst.faceDown = false;
      log(`発動: ${d.name}（Cost${cost}）`);

      if(d.effect?.kind === "damage") applyDamageEffect(owner, d.effect);

      moveToGrave(inst);
      render();
      return;
    }
  }

  function cardLabel(inst, viewer){
    const d = defOf(inst);
    const facedown = inst.faceDown && (viewer !== inst.owner);

    if(!d){
      return {top:"UNKNOWN", mid:"UNKNOWN", bot: inst.id};
    }

    if(facedown){
      if(d.cardType==="INSTANCE") return {top:"インスタンス", mid:"（伏せ）", bot:""};
      return {top:"（伏せ）", mid:"", bot:""};
    }

    let mid = "";
    if(d.cardType==="MONSTER") mid = `ATK:${d.atk ?? "-"} / HP:${d.hp ?? "-"}`;
    else if(d.cardType==="HERO"){
      const lp = (inst._lp!=null) ? inst._lp : (d.lp ?? "-");
      mid = `LP:${lp}`;
    }else if(d.cardType==="SUPPORT") mid = `LP:${d.lp ?? 1} / Cost:${d.cost ?? 0}`;
    else if(d.cardType==="SPELL") mid = `SPELL / Cost:${d.cost ?? 0}`;
    else if(d.cardType==="INSTANCE") mid = `INSTANCE`;

    let bot = "";
    if(d.cardType==="MONSTER" || d.cardType==="SUPPORT" || d.cardType==="SPELL") bot = `Cost:${d.cost ?? 0}`;
    return {top:d.name, mid, bot};
  }

  function slotHtml(inst, ref, viewer){
    if(!inst){
      return `<div class="slot" data-empty="1" data-zone="${esc(ref.zone)}" data-owner="${esc(ref.owner)}" data-index="${ref.index}">空</div>`;
    }
    const lab = cardLabel(inst, viewer);
    const d = defOf(inst);
    const badges = [];
    if(d?.cardType==="MONSTER" && inst.summonSick && inst.owner===viewer){
      badges.push(`<span class="badge warn">召喚酔い</span>`);
    }
    if(inst.faceDown && viewer!==inst.owner){
      badges.push(`<span class="badge info">伏せ</span>`);
    }
    return `
      <div class="slot fill" data-zone="${esc(ref.zone)}" data-owner="${esc(ref.owner)}" data-index="${ref.index}">
        <div class="badges">${badges.join("")}</div>
        <div style="width:100%">
          <div class="name">${esc(lab.top)}</div>
          <div class="meta">${esc(lab.mid)}</div>
          <div class="meta">${esc(lab.bot)}</div>
        </div>
      </div>
    `;
  }

  function renderSlotRow(el, arr, ctx){
    if(!el) return;
    const out = [];
    for(let i=0;i<ctx.max;i++){
      out.push(slotHtml(arr[i] || null, {owner:ctx.owner, zone:ctx.zone, index:i}, ctx.viewer));
    }
    el.innerHTML = out.join("");
  }

  function renderHand(){
    const el = $("handRow");
    if(!el) return;
    const p = state.players.P1;
    el.innerHTML = p.hand.map((inst, i) => {
      const d = defOf(inst);
      const title = d?.name ?? "UNKNOWN";
      const ctype = d?.cardType ?? "UNKNOWN";
      const cost = d?.cost ?? 0;
      return `
        <div class="card" data-zone="${Z.HAND}" data-owner="P1" data-index="${i}">
          <div class="name">${esc(title)}</div>
          <div class="meta">${esc(ctype)} / Cost:${esc(cost)}</div>
          <div class="meta">タップで詳細</div>
        </div>
      `;
    }).join("");
  }

  function render(){
    $("phaseLabel").textContent = state.phase;
    $("turnLabel").textContent = String(state.turn);
    $("activeLabel").textContent = state.active;

    renderSlotRow($("supportSlotsP2"), state.players.P2.support, {owner:"P2", zone:Z.SUP, viewer:"P1", max:7});
    renderSlotRow($("instanceSlotsP2"), state.players.P2.instance, {owner:"P2", zone:Z.INST, viewer:"P1", max:5});
    renderSlotRow($("heroSlotsP2"), state.players.P2.hero, {owner:"P2", zone:Z.HERO, viewer:"P1", max:4});
    renderSlotRow($("monsterSlotsP2"), state.players.P2.monster, {owner:"P2", zone:Z.MON, viewer:"P1", max:7});

    renderSlotRow($("monsterSlotsP1"), state.players.P1.monster, {owner:"P1", zone:Z.MON, viewer:"P1", max:7});
    renderSlotRow($("heroSlotsP1"), state.players.P1.hero, {owner:"P1", zone:Z.HERO, viewer:"P1", max:4});
    renderSlotRow($("instanceSlotsP1"), state.players.P1.instance, {owner:"P1", zone:Z.INST, viewer:"P1", max:5});
    renderSlotRow($("supportSlotsP1"), state.players.P1.support, {owner:"P1", zone:Z.SUP, viewer:"P1", max:7});

    renderHand();
  }

  function openModal(title, bodyHtml){
    $("modalTitle").textContent = title || "";
    $("modalBody").innerHTML = bodyHtml || "";
    $("modalBackdrop").style.display = "flex";
  }
  function closeModal(){
    $("modalBackdrop").style.display = "none";
  }

  function btn(label, act){
    return `<button class="primary" data-act="${act}">${esc(label)}</button>`;
  }

  function openPhasePicker(){
    const items = PHASES.map(p => {
      const cur = (p===state.phase) ? " (現在)" : "";
      return `<button class="primary" data-act="setPhase" data-phase="${p}">${p}${cur}</button>`;
    }).join("");
    openModal("フェイズ選択", `<div class="actionsRow">${items}</div><div class="small" style="margin-top:10px">※プロトタイプのため、任意フェイズへ遷移できます。</div>`);
  }

  function openCardDetails(ref){
    const {owner, zone, index} = ref;
    const p = state.players[owner];
    let inst = null;
    if(zone===Z.HAND) inst = p.hand[index];
    else if(zone===Z.MON) inst = p.monster[index];
    else if(zone===Z.SUP) inst = p.support[index];
    else if(zone===Z.INST) inst = p.instance[index];
    else if(zone===Z.HERO) inst = p.hero[index];
    if(!inst) return;

    const d = defOf(inst);
    const viewer = "P1";
    const facedown = (viewer!==inst.owner) && inst.faceDown;

    const header = facedown ? "（伏せカード）" : (d?.name ?? inst.id);
    const ctype = d?.cardType ?? "UNKNOWN";
    const meta = facedown ? "" : `${ctype} / Cost:${d?.cost ?? 0}`;
    const stats = facedown ? "" : (
      ctype==="MONSTER" ? `ATK:${d?.atk ?? "-"} / HP:${d?.hp ?? "-"}` :
      ctype==="HERO" ? `LP:${(inst._lp!=null)?inst._lp:(d?.lp ?? "-")}` :
      (ctype==="SUPPORT" ? `LP:${d?.lp ?? 1}` : "")
    );

    const buttons = [];
    if(owner==="P1"){
      if(zone===Z.HAND && ctype==="MONSTER") buttons.push(btn("召喚","summon"));
      if(zone===Z.HAND) buttons.push(btn("マナへ","mana"));
      if(zone===Z.HAND && (ctype==="SPELL"||ctype==="SUPPORT")) buttons.push(btn("セット","set"));
      if((ctype==="SPELL"||ctype==="SUPPORT") && (zone===Z.HAND || zone===Z.SUP)) buttons.push(btn("発動","activate"));
      if(ctype==="INSTANCE" && zone===Z.INST) buttons.push(btn("発動","activate"));
      if(ctype==="HERO" && zone===Z.HERO) buttons.push(btn("効果","activate"));
      if(ctype==="MONSTER" && zone===Z.MON) buttons.push(btn("効果","activate"));
    }

    openModal(header, `
      <div class="small">${esc(meta)}</div>
      <div class="hr"></div>
      <div class="small">${esc(stats)}</div>
      <div class="hr"></div>
      <div class="actionsRow">${buttons.join("") || `<div class="small">（このカードで実行できる操作はありません）</div>`}</div>
      <div class="hr"></div>
      <div class="small">ゾーン: ${esc(zone)} / Owner:${esc(owner)} / UID:${esc(inst.uid)}</div>
    `);

    const body = $("modalBody");
    for(const b of body.querySelectorAll("button[data-act]")){
      b.addEventListener("click", (ev) => {
        const act = ev.currentTarget.getAttribute("data-act");
        const phase = ev.currentTarget.getAttribute("data-phase");
        closeModal();
        if(act==="setPhase") setPhase(phase);
        if(act==="mana") actToMana(ref);
        if(act==="summon") actSummon(ref);
        if(act==="set") actSet(ref);
        if(act==="activate") actActivate(ref);
      }, {once:true});
    }
  }

  $("btnSetup").addEventListener("click", setupDemo);
  $("btnReset").addEventListener("click", resetGame);
  $("btnPhase").addEventListener("click", openPhasePicker);
  $("btnEndTurn").addEventListener("click", endTurn);
  $("btnCloseModal").addEventListener("click", closeModal);
  $("modalBackdrop").addEventListener("click", (e)=>{ if(e.target === $("modalBackdrop")) closeModal(); });

  document.addEventListener("click", (e) => {
    const node = e.target.closest("[data-zone][data-owner][data-index]");
    if(!node) return;
    if(node.getAttribute("data-empty")==="1") return;
    const zone = node.getAttribute("data-zone");
    const owner = node.getAttribute("data-owner");
    const index = Number(node.getAttribute("data-index"));
    if(Number.isNaN(index)) return;
    openCardDetails({owner, zone, index});
  });

  window.addEventListener("error", (e)=> log(`JS Error: ${e.message || "unknown"}`));
  window.addEventListener("unhandledrejection", (e)=> log(`Promise Rejection: ${e.reason?.message || e.reason || "unknown"}`));

  (async function init(){
    log(`起動: ${VERSION}`);
    await loadDefs();
    render();
  })();

})();
</script>
</body>
</html>
