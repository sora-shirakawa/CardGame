<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Card Game Prototype — v40</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(255,255,255,.06);
    --line:rgba(255,255,255,.12);
    --text:rgba(255,255,255,.92);
    --muted:rgba(255,255,255,.70);
    --good:#14532d;
    --warn:#7c2d12;
    --bad:#7f1d1d;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px;
  }
  *{box-sizing:border-box}
  body{margin:0;background:
      radial-gradient(1200px 600px at 40% -10%, rgba(125,211,252,.16), transparent),
      radial-gradient(900px 600px at 90% 10%, rgba(250,204,21,.10), transparent),
      var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
  }

  #jsStatus{position:sticky;top:0;z-index:9999;background:var(--bad);color:#fff;padding:10px 12px;font-weight:900;font-size:13px;border-bottom:1px solid rgba(255,255,255,.12)}
  header{position:sticky;top:44px;z-index:50;backdrop-filter: blur(10px);
          background:linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.68));
          border-bottom:1px solid var(--line);}
  .bar{display:flex;gap:10px;align-items:center;justify-content:space-between; padding:10px 12px; flex-wrap:wrap}
  .title{font-weight:900}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{appearance:none;border:1px solid var(--line);background:var(--panel);color:var(--text);
          padding:9px 12px;border-radius:12px;font-weight:800;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  button.primary{border-color:rgba(125,211,252,.35); box-shadow:0 0 0 1px rgba(125,211,252,.06) inset}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:5px 10px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid var(--line);font-size:12px}

  .wrap{
    display:grid;
    grid-template-columns: 1.45fr .55fr;
    gap:12px; padding:12px;
    max-width:1200px; margin:0 auto
  }
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  .panel{background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow: var(--shadow);}
  .panel h2{margin:0;padding:12px 12px 0 12px;font-size:14px;opacity:.95}
  .panel .inner{padding:12px}

  .fieldGrid{
    display:grid;
    grid-template-columns: 1fr 260px;
    gap:12px;
    align-items:start;
  }
  @media (max-width: 980px){ .fieldGrid{grid-template-columns:1fr} }

  .stack{display:flex;flex-direction:column;gap:10px}

  .zoneBox{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
  }
  .zoneHead{
    display:flex;align-items:center;justify-content:space-between;
    gap:10px;margin-bottom:8px
  }
  .zoneTitle{font-weight:900}
  .zoneNote{font-size:12px;color:var(--muted)}
  .hr{height:1px;background:var(--line);margin:10px 0}

  .slotRow{display:flex;gap:10px;flex-wrap:wrap}
  .slotRow.nowrap{flex-wrap:nowrap;overflow-x:auto;padding-bottom:6px}
  .slotRow.nowrap::-webkit-scrollbar{height:8px}
  .slotRow.nowrap::-webkit-scrollbar-thumb{background:rgba(255,255,255,.18);border-radius:999px}
  .slotRow.nowrap::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px}

  .slot{
    width:170px; height:92px;
    border-radius:14px;
    border:1px dashed rgba(255,255,255,.18);
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    color:rgba(255,255,255,.60);
    background:rgba(255,255,255,.03);
    padding:8px;
    text-align:center;
    user-select:none;
  }
  .slot.fill{border-style:solid;background:rgba(255,255,255,.05); cursor:pointer}
  .slot .t{font-weight:900;font-size:13px;line-height:1.2}
  .slot .m{font-size:12px;color:rgba(255,255,255,.78);margin-top:6px;line-height:1.2}
  .slot .b{font-size:12px;color:rgba(255,255,255,.72);margin-top:4px;line-height:1.2}
  .slot .tag{
    display:inline-block;margin-top:6px;
    font-size:11px;padding:3px 8px;border-radius:999px;
    background:rgba(255,255,255,.10);border:1px solid var(--line)
  }
  .slot .tag.down{background:rgba(29,78,216,.20);border-color:rgba(29,78,216,.45)}

  /* Heroes: vertical two rows (back over front) */
  .heroBlock{display:flex;flex-direction:column;gap:10px}
  .heroRowTitle{font-size:12px;color:var(--muted);font-weight:800;margin-bottom:6px}
  .heroRow{display:flex;flex-wrap:wrap;gap:10px}
  .heroRow.nowrap{flex-wrap:nowrap;overflow-x:auto;padding-bottom:6px}

  /* Modal */
  #modalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:100}
  #modal{width:min(860px, 94vw); max-height: 90vh; overflow:auto; background:rgba(12,18,36,.92); border:1px solid var(--line);
          border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.6)}
  .modalHead{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px;border-bottom:1px solid var(--line)}
  .modalHead .h{font-weight:900}
  .modalBody{padding:12px}
  .actionsRow{display:flex;gap:8px;flex-wrap:wrap}
  .pill{border-radius:999px;padding:8px 12px}

  /* Right rail boxes (確認) */
  .checkBox{padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04)}
  .checkBox .k{font-weight:900}
  .checkBox .v{margin-top:6px;font-size:12px;color:var(--muted)}
  .muted{color:var(--muted)}
</style>
</head>
<body>
<div id="jsStatus">JS未起動（v39）</div>

<header>
  <div class="bar">
    <div class="row">
      <div class="title">Card Game Prototype</div>
      <span class="chip" id="chipPhase">PHASE: -</span>
      <span class="chip" id="chipTurn">TURN: -</span>
      <span class="chip" id="chipActive">Active: -</span>
      <span class="chip" id="chipMana">P1 Mana: -</span>
    </div>
    <div class="row">
      <button class="primary" id="btnDemo">デモセットアップ</button>
      <button id="btnReset">リセット</button>
      <button id="btnPhase">フェイズ</button>
      <button id="btnEnd">ターン終了</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="panel">
    <h2>フィールド</h2>
    <div class="inner fieldGrid">
      <div class="stack">

        <!-- Opponent -->
        <div class="zoneBox">
          <div class="zoneHead">
            <div class="zoneTitle">相手フィールド（P2・ミラー）</div>
            <div class="zoneNote">常時表示</div>
          </div>

          <div class="stack">
            <div>
              <div class="zoneHead"><div class="zoneTitle">サポート・魔法</div><div class="zoneNote">最大10</div></div>
              <div class="slotRow nowrap" id="p2SupTop"></div>
          <div class="slotRow nowrap" id="p2SupBot"></div>
            </div>

            <div>
              <div class="zoneHead"><div class="zoneTitle">インスタンス</div><div class="zoneNote">最大5（伏せ）</div></div>
              <div class="slotRow nowrap" id="p2Inst"></div>
            </div>

            <div>
              <div class="zoneHead"><div class="zoneTitle">ヒーロー（前衛／後衛）</div><div class="zoneNote">各最大3／最低各1</div></div>
              <div class="heroBlock">
                <div>
                  <div class="heroRowTitle">後衛</div>
                  <div class="heroRow nowrap" id="p2HeroBack"></div>
                </div>
                <div>
                  <div class="heroRowTitle">前衛</div>
                  <div class="heroRow nowrap" id="p2HeroFront"></div>
                </div>
              </div>
            </div>

            <div>
              <div class="zoneHead"><div class="zoneTitle">モンスター</div><div class="zoneNote">最大10</div></div>
              <div class="slotRow nowrap" id="p2MonTop"></div>
          <div class="slotRow nowrap" id="p2MonBot"></div>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <!-- Self -->
        <div class="zoneBox">
          <div class="zoneHead">
            <div class="zoneTitle">自分フィールド（P1）</div>
            <div class="zoneNote">モンスター/サポートは横スクロール</div>
          </div>

          <div class="stack">
            <div>
              <div class="zoneHead"><div class="zoneTitle">モンスター</div><div class="zoneNote">最大10</div></div>
              <div class="slotRow nowrap" id="p1MonTop"></div>
          <div class="slotRow nowrap" id="p1MonBot"></div>
            </div>

            <div>
              <div class="zoneHead"><div class="zoneTitle">ヒーロー（前衛／後衛）</div><div class="zoneNote">入れ替え: 1ターン1回/1マナ（戦闘不能は対象外）</div></div>
              <div class="heroBlock">
                <div>
                  <div class="heroRowTitle">前衛</div>
                  <div class="heroRow nowrap" id="p1HeroFront"></div>
                </div>
                <div>
                  <div class="heroRowTitle">後衛</div>
                  <div class="heroRow nowrap" id="p1HeroBack"></div>
                </div>
              </div>
            </div>

            <div>
              <div class="zoneHead"><div class="zoneTitle">インスタンス</div><div class="zoneNote">最大5（相手から非公開／発動時のみ公開）</div></div>
              <div class="slotRow nowrap" id="p1Inst"></div>
            </div>

            <div>
              <div class="zoneHead"><div class="zoneTitle">サポート・魔法</div><div class="zoneNote">最大10</div></div>
              <div class="slotRow nowrap" id="p1SupTop"></div>
          <div class="slotRow nowrap" id="p1SupBot"></div>
            </div>

            <div>
              <div class="zoneHead"><div class="zoneTitle">手札（P1）</div><div class="zoneNote">最大10（エンドまで枚数制限なし運用は後で実装）</div></div>
              <div class="slotRow nowrap" id="p1Hand"></div>
            </div>
          </div>
        </div>

      </div>

      <!-- Right rail: check + log -->
      <div class="stack">
        <div class="checkBox">
          <div class="k">現在のターン数</div>
          <div class="v" id="boxTurn">-</div>
        </div>
        <div class="checkBox">
          <div class="k">現在のフェイズ</div>
          <div class="v" id="boxPhase">-</div>
        </div>
        <div class="checkBox">
          <div class="k">ログ（スクロール）</div>
          <div class="v muted">操作ログ（簡易）</div>
          <pre id="log" style="white-space:pre-wrap;margin:8px 0 0 0;max-height:38vh;overflow:auto"></pre>
        </div>
        <div class="checkBox">
          <div class="k">相手墓地確認</div><div class="v muted">（後でUI実装）</div>
        </div>
        <div class="checkBox">
          <div class="k">相手除外ゾーン確認</div><div class="v muted">（後でUI実装）</div>
        </div>
        <div class="checkBox">
          <div class="k">自分墓地確認</div><div class="v muted">（後でUI実装）</div>
        </div>
        <div class="checkBox">
          <div class="k">自分除外ゾーン確認</div><div class="v muted">（後でUI実装）</div>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- Modal -->
<div id="modalBackdrop">
  <div id="modal">
    <div class="modalHead">
      <div class="h" id="modalTitle">詳細</div>
      <button id="btnCloseModal">閉じる</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
  </div>
</div>

<script>
(() => {
  "use strict";
  const VERSION = "v40";

  const $ = (id)=>document.getElementById(id);
  const esc = (s)=>String(s??"").replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;", "\"":"&quot;","'":"&#39;" }[m]));
  const now = ()=>new Date().toLocaleTimeString();

  const Z = {
    MON:"monster",
    HERO_F:"heroFront",
    HERO_B:"heroBack",
    INST:"instance",
    SUP:"support",
    HAND:"hand",
    MANA:"mana",
    GRAVE:"grave",
    BANISH:"banish",
  };
  const PHASES = ["DRAW","MAIN","BATTLE","END"];

  function makeEmptyPlayer(){
    return {
      monster: Array(10).fill(null),
      heroFront: Array(3).fill(null),
      heroBack: Array(3).fill(null),
      instance: Array(5).fill(null),
      support: Array(10).fill(null),
      hand: [],
      mana: [],
      grave: [],
      banish: [],
    };
  }

  function uid(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }
  function makeCardInst(id, owner){
    return { uid: uid(), id, owner, zone:"", faceDown:false, tapped:false, summonSick:false, _lp:null };
  }

  const state = {
    defsById: new Map(),
    defsLoaded:false,

    turn:1,
    active:"P1",
    phase:"MAIN",
    perTurn:{ P1:{manaSet:false, heroSwap:false}, P2:{manaSet:false, heroSwap:false} },

    players:{ P1:makeEmptyPlayer(), P2:makeEmptyPlayer() },
    modal:{ open:false, ref:null }
  };

  const dom = {};

  function log(msg){
    const el = dom.log;
    if(!el) return;
    el.textContent = (el.textContent + msg + "\n").slice(-12000);
    el.scrollTop = el.scrollHeight;
  }

  function updateJsStatus(ok){
    const el = $("jsStatus");
    if(!el) return;
    if(ok){
      el.textContent = `JS ready (${VERSION})`;
      el.style.background = "var(--good)";
    }else{
      el.textContent = `JS未起動（${VERSION}）`;
      el.style.background = "var(--bad)";
    }
  }

  function cacheDom(){
    dom.p1MonTop = $("p1MonTop");
    dom.p1MonBot = $("p1MonBot");
    dom.p1HeroFront = $("p1HeroFront");
    dom.p1HeroBack = $("p1HeroBack");
    dom.p1Inst = $("p1Inst");
    dom.p1SupTop = $("p1SupTop");
    dom.p1SupBot = $("p1SupBot");
    dom.p1Hand = $("p1Hand");

    dom.p2MonTop = $("p2MonTop");
    dom.p2MonBot = $("p2MonBot");
    dom.p2HeroFront = $("p2HeroFront");
    dom.p2HeroBack = $("p2HeroBack");
    dom.p2Inst = $("p2Inst");
    dom.p2SupTop = $("p2SupTop");
    dom.p2SupBot = $("p2SupBot");

    dom.chipPhase = $("chipPhase");
    dom.chipTurn = $("chipTurn");
    dom.chipActive = $("chipActive");
    dom.chipMana = $("chipMana");

    dom.boxTurn = $("boxTurn");
    dom.boxPhase = $("boxPhase");

    dom.log = $("log");

    dom.btnDemo = $("btnDemo");
    dom.btnReset = $("btnReset");
    dom.btnPhase = $("btnPhase");
    dom.btnEnd = $("btnEnd");

    dom.modalBackdrop = $("modalBackdrop");
    dom.modalTitle = $("modalTitle");
    dom.modalBody = $("modalBody");
    dom.btnCloseModal = $("btnCloseModal");
  }

  // cards.json can be array OR {cards:[...]}
  async function loadDefs(){
    try{
      const url = "cards.json?t=" + Date.now();
      const res = await fetch(url, {cache:"no-store"});
      if(!res.ok) throw new Error("cards.json status: " + res.status);
      const j = await res.json();
      const arr = Array.isArray(j) ? j : (Array.isArray(j.cards) ? j.cards : null);
      if(!arr) throw new Error("cards.json format invalid (expected array or {cards:[..]})");
      const map = new Map();
      for(const d of arr){
        if(d && d.id) map.set(d.id, normalizeDef(d));
      }
      state.defsById = map;
      state.defsLoaded = true;
      log(`cards.json loaded (${map.size} cards)`);
      return true;
    }catch(e){
      state.defsLoaded = false;
      log("cards.json 読み込み失敗: " + (e?.message || e));
      // minimal fallback
      const fallback = [
        {id:"H_FB", name:"フォールバック先導者", cardType:"HERO", lp:5, rarity:"N"},
        {id:"M_FB", name:"フォールバック兵", cardType:"MONSTER", subType:"S", cost:1, atk:100, hp:200, rarity:"N"},
        {id:"SP_FB", name:"フォールバック魔法", cardType:"SPELL", cost:1, rarity:"N"},
        {id:"SU_FB", name:"フォールバック支援", cardType:"SUPPORT", cost:1, lp:1, rarity:"N"},
        {id:"IN_FB", name:"フォールバック・インスタンス", cardType:"INSTANCE", rarity:"N"},
      ];
      state.defsById = new Map(fallback.map(x=>[x.id,x]));
      return false;
    }
  }

  // Accept your schema: type: hero/monster/magic/support/instance
  function normalizeDef(d){
    const t = String(d.cardType ?? d.type ?? "").toLowerCase();
    if(t==="hero") return {...d, cardType:"HERO"};
    if(t==="monster") return {...d, cardType:"MONSTER"};
    if(t==="magic" || t==="spell") return {...d, cardType:"SPELL"};
    if(t==="support") return {...d, cardType:"SUPPORT"};
    if(t==="instance") return {...d, cardType:"INSTANCE"};
    // already normalized?
    const up = String(d.cardType||"").toUpperCase();
    if(["HERO","MONSTER","SPELL","SUPPORT","INSTANCE"].includes(up)) return d;
    return {...d, cardType:String(d.cardType||d.type||"UNKNOWN").toUpperCase()};
  }

  function defOf(inst){ return inst ? (state.defsById.get(inst.id) || null) : null; }

  function manaAvailable(owner){
    let n=0;
    for(const c of state.players[owner].mana){
      if(c && !c.tapped) n++;
    }
    return n;
  }

  function untapAllMana(owner){
    for(const c of state.players[owner].mana){ if(c) c.tapped=false; }
  }

  function tapMana(owner, n){
    let need=n;
    for(const c of state.players[owner].mana){
      if(need<=0) break;
      if(c && !c.tapped){ c.tapped=true; need--; }
    }
    return need===0;
  }

  function resetGame(){
    state.turn=1; state.active="P1"; state.phase="MAIN";
    state.perTurn.P1={manaSet:false, heroSwap:false};
    state.perTurn.P2={manaSet:false, heroSwap:false};
    state.players.P1 = makeEmptyPlayer();
    state.players.P2 = makeEmptyPlayer();
    closeModal();
    log("リセットしました。");
    render();
  }

  function pickMany(pred, n){
    const out=[];
    for(const d of state.defsById.values()){
      if(pred(d)) out.push(d.id);
      if(out.length>=n) break;
    }
    return out;
  }

  function setupDemo(){
    resetGame();

    const heroIds = pickMany(d=>String(d.cardType).toUpperCase()==="HERO", 6);
    const instIds = pickMany(d=>String(d.cardType).toUpperCase()==="INSTANCE", 6);
    const monIds  = pickMany(d=>String(d.cardType).toUpperCase()==="MONSTER", 8);
    const supIds  = pickMany(d=>String(d.cardType).toUpperCase()==="SUPPORT", 8);
    const splIds  = pickMany(d=>String(d.cardType).toUpperCase()==="SPELL", 8);

    // P1 heroes: 2 front, 2 back (later: selection)
    for(let i=0;i<2;i++){
      const id = heroIds[i] || "H_FB";
      const c = makeCardInst(id,"P1"); c.zone=Z.HERO_F;
      state.players.P1.heroFront[i]=c;
    }
    for(let i=0;i<2;i++){
      const id = heroIds[i+2] || heroIds[0] || "H_FB";
      const c = makeCardInst(id,"P1"); c.zone=Z.HERO_B;
      state.players.P1.heroBack[i]=c;
    }

    // P2 heroes: 2 front, 2 back (mirrored display but same data)
    for(let i=0;i<2;i++){
      const id = heroIds[i+1] || "H_FB";
      const c = makeCardInst(id,"P2"); c.zone=Z.HERO_F;
      state.players.P2.heroFront[i]=c;
    }
    for(let i=0;i<2;i++){
      const id = heroIds[i+3] || heroIds[0] || "H_FB";
      const c = makeCardInst(id,"P2"); c.zone=Z.HERO_B;
      state.players.P2.heroBack[i]=c;
    }

    // Instances
    for(let i=0;i<3;i++){
      const id = instIds[i] || "IN_FB";
      const c1 = makeCardInst(id,"P1"); c1.zone=Z.INST; c1.faceDown=true;
      state.players.P1.instance[i]=c1;
      const c2 = makeCardInst(id,"P2"); c2.zone=Z.INST; c2.faceDown=true;
      state.players.P2.instance[i]=c2;
    }

    // Opponent has 1 monster and 1 support facedown
    if(monIds[0]){
      const m = makeCardInst(monIds[0],"P2"); m.zone=Z.MON;
      state.players.P2.monster[0]=m;
    }
    if(supIds[0]){
      const s = makeCardInst(supIds[0],"P2"); s.zone=Z.SUP; s.faceDown=true;
      state.players.P2.support[0]=s;
    }

    // Hand
    const hand = [];
    for(const id of [...monIds, ...splIds, ...supIds]){
      if(hand.length>=6) break;
      hand.push(id);
    }
    state.players.P1.hand = hand.map(id=>{ const c=makeCardInst(id||"M_FB","P1"); c.zone=Z.HAND; return c; });

    // Mana: take first 2 hand cards as mana faceup (for demo)
    for(let i=0;i<2;i++){
      const h = state.players.P1.hand[i];
      const id = h ? h.id : (monIds[0]||"M_FB");
      const c = makeCardInst(id,"P1"); c.zone=Z.MANA;
      state.players.P1.mana.push(c);
    }

    log("デモセットアップ完了。");
    render();
  }

  function render(){
    // chips
    if(dom.chipPhase) dom.chipPhase.textContent = "PHASE: " + state.phase;
    if(dom.chipTurn) dom.chipTurn.textContent = "TURN: " + state.turn;
    if(dom.chipActive) dom.chipActive.textContent = "Active: " + state.active;
    if(dom.chipMana) dom.chipMana.textContent = `P1 Mana: ${state.players.P1.mana.length} (${manaAvailable("P1")} untapped)`;
    if(dom.boxTurn) dom.boxTurn.textContent = String(state.turn);
    if(dom.boxPhase) dom.boxPhase.textContent = state.phase;

    // opponent
    renderSplit(dom.p2SupTop, dom.p2SupBot, state.players.P2.support, {owner:"P2", zone:Z.SUP, viewer:"P1"}, 5);
    renderRow(dom.p2Inst, state.players.P2.instance, {owner:"P2", zone:Z.INST, viewer:"P1", max:5});
    renderRow(dom.p2HeroBack, state.players.P2.heroBack, {owner:"P2", zone:Z.HERO_B, viewer:"P1", max:3});
    renderRow(dom.p2HeroFront, state.players.P2.heroFront, {owner:"P2", zone:Z.HERO_F, viewer:"P1", max:3});
    renderSplit(dom.p2MonTop, dom.p2MonBot, state.players.P2.monster, {owner:"P2", zone:Z.MON, viewer:"P1"}, 5);

    // self
    renderSplit(dom.p1MonTop, dom.p1MonBot, state.players.P1.monster, {owner:"P1", zone:Z.MON, viewer:"P1"}, 5);
    renderRow(dom.p1HeroFront, state.players.P1.heroFront, {owner:"P1", zone:Z.HERO_F, viewer:"P1", max:3});
    renderRow(dom.p1HeroBack, state.players.P1.heroBack, {owner:"P1", zone:Z.HERO_B, viewer:"P1", max:3});
    renderRow(dom.p1Inst, state.players.P1.instance, {owner:"P1", zone:Z.INST, viewer:"P1", max:5});
    renderSplit(dom.p1SupTop, dom.p1SupBot, state.players.P1.support, {owner:"P1", zone:Z.SUP, viewer:"P1"}, 5);
    renderHand();
  }

  function cardLabel(inst, viewer){
    const d = defOf(inst);
    const ctype = String(d?.cardType||"").toUpperCase();
    const facedown = inst.faceDown && (viewer !== inst.owner);

    if(facedown){
      if(ctype==="INSTANCE") return {t:"インスタンス", m:"（伏せ）", b:""};
      if(ctype==="SUPPORT" || ctype==="SPELL") return {t:"（伏せ）", m:"", b:""};
    }

    const name = d?.name || inst.id;
    let mid = "";
    if(ctype==="MONSTER"){
      mid = `ATK:${d?.atk ?? "-"} / HP:${d?.hp ?? "-"}`;
    }else if(ctype==="HERO"){
      const lp = inst._lp!=null ? inst._lp : (d?.lp ?? "-");
      mid = `LP:${lp}`;
    }else if(ctype==="SUPPORT"){
      mid = `SUPPORT / LP:${d?.lp ?? 1}`;
    }else if(ctype==="SPELL"){
      mid = `SPELL / Cost:${d?.cost ?? 0}`;
    }else if(ctype==="INSTANCE"){
      mid = `INSTANCE`;
    }else{
      mid = ctype || "UNKNOWN";
    }
    const bot = (d?.cost!=null && (ctype==="MONSTER"||ctype==="SPELL"||ctype==="SUPPORT")) ? `Cost:${d.cost}` : "";
    return {t:name, m:mid, b:bot};
  }

  function renderRow(container, arr, ctx){
    if(!container) return;
    container.innerHTML = "";
    const {owner, zone, viewer, max} = ctx;
    for(let i=0;i<max;i++){
      const inst = arr[i] || null;
      const el = document.createElement("div");
      el.className = "slot" + (inst ? " fill" : "");
      el.dataset.owner = owner;
      el.dataset.zone = zone;
      el.dataset.index = String(i);

      if(!inst){
        el.innerHTML = `<div class="t">空</div>`;
      }else{
        const L = cardLabel(inst, viewer);
        const d = defOf(inst);
        const ctype = String(d?.cardType||"").toUpperCase();
        const down = (inst.faceDown && viewer!==inst.owner);
        el.innerHTML = `
          <div class="t">${esc(L.t)}</div>
          <div class="m">${esc(L.m)}</div>
          <div class="b">${esc(L.b)}</div>
          ${down ? `<span class="tag down">伏せ</span>` : ``}
        `;
        el.addEventListener("click", ()=>openDetails({owner, zone, index:i+offset}));
      }
      container.appendChild(el);
    }
  }


  function renderSplit(topEl, botEl, arr, opt, split=5){
    const a = Array.isArray(arr) ? arr : [];
    renderRow(topEl, a.slice(0, split), {...opt, max: split}, 0);
    renderRow(botEl, a.slice(split, split+split), {...opt, max: split}, split);
  }

  function renderHand(){
    const container = dom.p1Hand;
    if(!container) return;
    container.innerHTML = "";
    const arr = state.players.P1.hand;
    const max = Math.max(10, arr.length);
    for(let i=0;i<max;i++){
      const inst = arr[i] || null;
      const el = document.createElement("div");
      el.className = "slot" + (inst ? " fill" : "");
      el.style.height = "78px";
      if(!inst){
        el.innerHTML = `<div class="t">空</div>`;
      }else{
        const d = defOf(inst);
        const ctype = String(d?.cardType||"").toUpperCase();
        const name = d?.name || inst.id;
        const cost = (d?.cost!=null) ? `Cost:${d.cost}` : "";
        el.innerHTML = `
          <div class="t">${esc(name)}</div>
          <div class="m">${esc(ctype)} ${cost ? " / "+esc(cost) : ""}</div>
          <div class="b muted">タップで詳細</div>
        `;
        el.addEventListener("click", ()=>openDetails({owner:"P1", zone:Z.HAND, index:i}));
      }
      container.appendChild(el);
    }
  }

  function closeModal(){
    if(!dom.modalBackdrop) return;
    dom.modalBackdrop.style.display = "none";
    state.modal.open=false;
    state.modal.ref=null;
  }
  function openModal(title, html){
    if(dom.modalTitle) dom.modalTitle.textContent = title || "";
    if(dom.modalBody) dom.modalBody.innerHTML = html || "";
    if(dom.modalBackdrop) dom.modalBackdrop.style.display = "flex";
    state.modal.open=true;
  }

  function openDetails(ref){
    const {owner, zone, index} = ref;
    const p = state.players[owner];
    let inst=null;
    if(zone===Z.HAND) inst = p.hand[index];
    else if(zone===Z.MON) inst = p.monster[index];
    else if(zone===Z.SUP) inst = p.support[index];
    else if(zone===Z.INST) inst = p.instance[index];
    else if(zone===Z.HERO_F) inst = p.heroFront[index];
    else if(zone===Z.HERO_B) inst = p.heroBack[index];
    if(!inst) return;

    const d = defOf(inst);
    const ctype = String(d?.cardType||"").toUpperCase();
    const viewer="P1";
    const facedown = (viewer !== inst.owner) && inst.faceDown;

    const title = facedown ? "（伏せカード）" : (d?.name || inst.id);
    const meta = facedown ? "" : `${ctype}${d?.rarity ? " / "+d.rarity : ""}${d?.cost!=null ? " / Cost:"+d.cost : ""}`;

    let stats = "";
    if(!facedown){
      if(ctype==="MONSTER") stats = `ATK:${d?.atk ?? "-"} / HP:${d?.hp ?? "-"}`;
      if(ctype==="HERO") stats = `LP:${inst._lp!=null ? inst._lp : (d?.lp ?? "-")}`;
      if(ctype==="SUPPORT") stats = `LP:${d?.lp ?? 1}`;
    }

    const body = `
      <div class="muted" style="font-size:12px">${esc(meta)}</div>
      <div class="hr"></div>
      <div style="font-size:13px">${esc(stats)}</div>
      <div class="hr"></div>
      <div class="actionsRow">
        ${owner==="P1" && zone===Z.HAND ? `<button class="primary" data-act="toMana">マナへ</button>` : ``}
        ${owner==="P1" && zone===Z.HAND && ctype==="MONSTER" ? `<button class="primary" data-act="summon">召喚</button>` : ``}
        ${owner==="P1" && zone===Z.HAND && (ctype==="SPELL"||ctype==="SUPPORT") ? `<button class="primary" data-act="set">セット</button>` : ``}
        ${(owner==="P1" && (zone===Z.SUP || zone===Z.INST || zone===Z.HAND) && (ctype==="SPELL"||ctype==="SUPPORT"||ctype==="INSTANCE")) ? `<button class="primary" data-act="activate">発動</button>` : ``}
        <button data-act="close">閉じる</button>
      </div>
      <div class="hr"></div>
      <div class="muted" style="font-size:12px">Owner:${esc(owner)} / Zone:${esc(zone)} / UID:${esc(inst.uid)}</div>
    `;
    state.modal.ref = ref;
    openModal(title, body);

    // bind modal action buttons
    dom.modalBody.querySelectorAll("button[data-act]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const act = btn.getAttribute("data-act");
        if(act==="close"){ closeModal(); return; }
        if(!state.modal.ref) return;
        if(act==="toMana") actToMana(state.modal.ref);
        if(act==="summon") actSummon(state.modal.ref);
        if(act==="set") actSet(state.modal.ref);
        if(act==="activate") actActivate(state.modal.ref);
      });
    });
  }

  function requireActive(owner){
    if(owner !== state.active){ log("自分の手番ではありません。"); return false; }
    return true;
  }

  function actToMana(ref){
    const {owner, zone, index} = ref;
    if(!requireActive(owner)) return;
    if(zone!==Z.HAND){ log("手札からのみマナ化できます。"); return; }
    if(state.perTurn[owner].manaSet){ log("このターンは既にマナ化しました。"); return; }

    const p = state.players[owner];
    const inst = p.hand[index];
    if(!inst) return;
    p.hand.splice(index,1);
    inst.zone = Z.MANA;
    inst.tapped = false;
    p.mana.push(inst);
    state.perTurn[owner].manaSet = true;
    log(`マナへ: ${defOf(inst)?.name || inst.id}`);
    closeModal();
    render();
  }

  function actSummon(ref){
    const {owner, zone, index} = ref;
    if(!requireActive(owner)) return;
    if(zone!==Z.HAND){ log("召喚は手札からのみ。"); return; }
    if(state.phase!=="MAIN"){ log("召喚はMAINのみ。"); return; }

    const p = state.players[owner];
    const inst = p.hand[index];
    const d = defOf(inst);
    if(!d) return;
    const ctype = String(d.cardType).toUpperCase();
    if(ctype!=="MONSTER"){ log("モンスター以外は召喚できません。"); return; }
    const cost = Number(d.cost||0);
    if(manaAvailable(owner) < cost){ log(`マナ不足（必要${cost} / 残${manaAvailable(owner)}）。`); return; }

    const slot = p.monster.findIndex(x=>!x);
    if(slot<0){ log("モンスターゾーンが満杯です。"); return; }

    tapMana(owner, cost);
    p.hand.splice(index,1);
    inst.zone = Z.MON;
    inst.summonSick = true;
    p.monster[slot]=inst;
    log(`召喚: ${d.name}（Cost${cost}）`);
    closeModal();
    render();
  }

  function actSet(ref){
    const {owner, zone, index} = ref;
    if(!requireActive(owner)) return;
    if(zone!==Z.HAND){ log("セットは手札からのみ。"); return; }
    if(state.phase!=="MAIN"){ log("セットはMAINのみ。"); return; }

    const p = state.players[owner];
    const inst = p.hand[index];
    const d = defOf(inst);
    if(!d) return;
    const ctype = String(d.cardType).toUpperCase();
    if(!(ctype==="SPELL" || ctype==="SUPPORT")){ log("魔法/サポートのみセット可能。"); return; }

    const cost = Number(d.cost||0);
    if(manaAvailable(owner) < cost){ log(`マナ不足（必要${cost} / 残${manaAvailable(owner)}）。`); return; }

    const slot = p.support.findIndex(x=>!x);
    if(slot<0){ log("サポート・魔法ゾーンが満杯です。"); return; }

    tapMana(owner, cost);
    p.hand.splice(index,1);
    inst.zone = Z.SUP;
    inst.faceDown = true;
    p.support[slot]=inst;
    log(`セット: ${d.name}（Cost${cost}）`);
    closeModal();
    render();
  }

  function moveToGrave(inst){
    const p = state.players[inst.owner];
    inst.zone = Z.GRAVE;
    inst.faceDown=false;
    inst.tapped=false;
    inst.summonSick=false;
    p.grave.push(inst);
  }

  function actActivate(ref){
    const {owner, zone, index} = ref;
    if(!requireActive(owner)) return;

    const p = state.players[owner];
    let inst=null;
    if(zone===Z.HAND) inst = p.hand[index];
    else if(zone===Z.SUP) inst = p.support[index];
    else if(zone===Z.INST) inst = p.instance[index];
    else { log("この領域からは発動できません。"); return; }
    if(!inst) return;

    const d = defOf(inst);
    const ctype = String(d?.cardType||"").toUpperCase();
    const cost = Number(d?.cost||0);

    // Instance: reveal on activate then banish (temporary: grave later)
    if(ctype==="INSTANCE"){
      if(zone!==Z.INST){ log("インスタンスはインスタンスゾーンからのみ。"); return; }
      inst.faceDown=false;
      log(`インスタンス発動: ${d?.name||inst.id}（※効果処理は次段）`);
      // remove from field, send to banish per your rule
      p.instance[index]=null;
      inst.zone = Z.BANISH;
      p.banish.push(inst);
      closeModal();
      render();
      return;
    }

    // Spell / Support activation
    if(ctype==="SPELL" || ctype==="SUPPORT"){
      if(manaAvailable(owner) < cost){ log(`マナ不足（必要${cost} / 残${manaAvailable(owner)}）。`); return; }
      tapMana(owner, cost);

      // If from hand: support should "activate and place" (設置型) later; for now, treat like spell -> grave.
      // If from set zone: flip up and keep for support (設置) - we keep it on field.
      const isSupport = (ctype==="SUPPORT");
      const fromHand = (zone===Z.HAND);
      const fromSet = (zone===Z.SUP);

      if(fromHand){
        p.hand.splice(index,1);
      }else{
        p.support[index]=null;
      }

      inst.faceDown=false;
      log(`発動: ${d?.name||inst.id}（Cost${cost}）`);

      if(isSupport){
        // place it faceup into first empty support slot
        const slot = p.support.findIndex(x=>!x);
        if(slot>=0){
          inst.zone = Z.SUP;
          p.support[slot]=inst;
          log("→ サポートを設置しました。");
        }else{
          // if no space, drop to grave as fallback
          moveToGrave(inst);
          log("→ サポートゾーン満杯のため墓地へ（暫定）。");
        }
      }else{
        moveToGrave(inst);
      }

      closeModal();
      render();
      return;
    }

    log("（このカードは発動未実装）");
  }

  function openPhasePicker(){
    const items = PHASES.map(p=>{
      const cur = (p===state.phase) ? "（現在）" : "";
      return `<button class="pill primary" data-phase="${p}">${esc(p)} ${esc(cur)}</button>`;
    }).join(" ");
    openModal("フェイズ選択", `<div class="actionsRow">${items}</div><div class="hr"></div><div class="muted" style="font-size:12px">※プロトタイプのため任意遷移。</div>`);
    dom.modalBody.querySelectorAll("button[data-phase]").forEach(b=>{
      b.addEventListener("click", ()=>{
        const p = b.getAttribute("data-phase");
        if(PHASES.includes(p)){ state.phase=p; log("フェイズ: "+p); closeModal(); render(); }
      });
    });
  }

  function endTurn(){
    state.phase = "END";
    state.active = (state.active==="P1") ? "P2" : "P1";
    if(state.active==="P1") state.turn += 1;

    state.perTurn[state.active].manaSet=false;
    state.perTurn[state.active].heroSwap=false;

    untapAllMana(state.active);

    // clear summon sickness for active player's monsters
    for(const c of state.players[state.active].monster){
      if(c) c.summonSick=false;
    }

    state.phase = "DRAW";
    log(`ターン交代: Active=${state.active} / Turn=${state.turn}`);
    render();
  }

  function bindEvents(){
    dom.btnDemo?.addEventListener("click", setupDemo);
    dom.btnReset?.addEventListener("click", resetGame);
    dom.btnPhase?.addEventListener("click", openPhasePicker);
    dom.btnEnd?.addEventListener("click", endTurn);
    dom.btnCloseModal?.addEventListener("click", closeModal);
    dom.modalBackdrop?.addEventListener("click", (e)=>{ if(e.target===dom.modalBackdrop) closeModal(); });
  }

  async function init(){
    cacheDom();
    updateJsStatus(true);
    bindEvents();
    await loadDefs();
    render();
  }

  window.addEventListener("error", (e)=>{
    console.error(e);
    log("JS Error: " + (e.message||"unknown"));
  });
  window.addEventListener("unhandledrejection", (e)=>{
    console.error(e);
    log("Promise Rejection: " + (e.reason?.message||e.reason||"unknown"));
  });

  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", init, {once:true});
  }else{
    init();
  }
})();
</script>
</body>
</html>
